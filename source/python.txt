*********************
Basic Python Concepts
*********************

**Revision History**

| 5.5 - June 2015: Joseph Long, Meredith Durbin
| 5.0 - June 2014: Katie Gosmeyer, Heather Gunning, Matthew Bourque
| 4.0 - September 2013: Justin Ely, Thompson LeBlanc
| 3.0 - January 2012: Rachel Anderson
| 2.0 - October 2009: Sami-Matias Niemi
| 1.0 - September 2008: Alex Viana

\

Introduction
============

Python is a free, open-source, high level interpreted scripting
language, similar to PERL. However, Python is also a high-level
object-oriented programming language, much like C++, Java, and Ruby.

The intention of this tutorial is to provide the Python basics to
understand how to perform simple astronomical data analysis.

We will discuss how to write and run Python scripts in
:ref:`python_scripts`. Until then we will use Python interactively, which
is best for learning Python and for checking your code as you write it.

A Few Notes on Python
---------------------

For those who already know a programming language or two, an important part of learning a new language is finding out which parts of your knowledge will carry over and which won't. Rather than providing an exhaustive tutorial on syntax [#pythontutorial]_, we will point out some key ideas (and traps for users used to other languages).

-  If you're coming from a **C or Java-like background**, note that Python does not use curly braces to denote "blocks" of code (e.g. the body of a loop or a conditional). Instead, blocks are indented by four spaces, and Python detects the end of a block when you return to the "outer" level of indentation.

   For example, this C code::

      if (myinteger > 0) {
         handle_over_zero_case();
      }
      do_something_else();

   Would look like this in Python::

      if myinteger > 0:
          handle_over_zero_case()
      do_something_else()

-  Similarly, semicolons are unnecessary to end lines.
   (In fact, it is considered poor style to use semicolons in Python code, though it is not a syntax error.)

   \

-  If you're coming from an **IDL background**, be aware that there is no equivalent to the common ``proc_name, argument1, argument2`` syntax. (Function calls in Python will always look like ``function_name(argument1, argument2)``.)

   \

- Similarly, there are no ``begin`` and ``endif`` keywords. Blocks are introduced with a colon and indentation, and ended by returning to the previous indentation level. (See the example code above.)

\

-  When referring to an element of a sequence, the indices count from zero.
   (That is, the first element of ``mylist`` would be ``mylist[0]``.)

   \

- When working with image data (or any 2D arrays), indexing follows matrix conventions of row-column, rather than Cartesian (x, y). This means accessing an element of an array in row "y" and column "x" looks like ``myarray[y,x]`` (rather than ``myarray[x,y]``).

   \

-  Python is case sensitive. That is, a variable named ``varONE`` cannot be referred to as ``varone``. Language keywords like ``if``, ``for``, ``while``, etc. are always lowercase.

   \

-  Comments in code are useful to help you remember what is going on,
   but also so that others know what you are doing. In Python, comment text
   begins with the ``#`` symbol and goes to the end of the line.

   For example::

      # a comment

   ::

      do_something()  # a comment sharing a line

   ::

      # a multi
      # line
      # comment

   \

-  The line continuation symbol ``\`` can be used to spread an expression
   out over multiple lines. There are constructs in Python that use parentheses,
   square brackets (``[]``), or curly braces (``{}``). Inside those, Python will
   wait for the closing symbol before assuming the end of the line.

Environment and Set Up
======================

SSB Environment
---------------

On your work computer, the easiest way to access up-to-date versions of Python and related tools is with the :ref:`Institute's SSB packages <computer_setup_ureka>`. For the purposes of this training, we will use ``ssbx``, which you activate in a terminal by typing::

   $ ssbx

.. note::

   In this text, when discussing commands to be typed at a command prompt, ``$`` is a placeholder for your command prompt (which may be something like ``yourname@localhost $``). You don't need to type it, just the commands following it.


Interactive Python Environment
------------------------------

You will need to choose an interactive Python environment. There are three
popular options.

- **Python**

  To start the Python interactive environment, just type ``python`` at
  the prompt in your terminal.

\

- **IPython**

  To use the IPython interactive environment, type ``ipython`` instead.
  One advantage of IPython is that besides Python code, you are also
  able to execute UNIX commands such as ``ls`` and ``cp`` without special syntax,
  or any UNIX shell command by including a ``!`` prefix at the beginning of a line.

\

- **IPython Notebook** (a.k.a. Jupyter Notebook)

  The notebook is an interactive web based interface to the IPython environment described above. It combines code, text, math, plots, and rich media into a single document with all the functionality of IPython.

  IPython Notebook can be started in the terminal with the command ``ipython notebook``. It will open a web browser window with the notebook interface.

  After it starts, choose the button for a new Python 2 notebook, and click on the "Untitled" heading to rename it. Both the code you write and any output generated will be saved when you click the save button.

To exit either Python or IPython, type 'exit()'. To close the notebook, ensure you've saved your work, then :kbd:`Ctrl-C` in the terminal window to interrupt it and "y" to confirm you want to quit.

.. note::

   In this text, when discussing commands to be typed at a Python interactive interpreter prompt, ``>>>`` is a placeholder for your command prompt (which will look like ``>>>``, or ``In [#]:`` if you're using IPython). An ellipsis (``...``) indicates a continuation of the preceding block or expression. (Enter a blank line to conclude the block or expression.)

.. note::

   Exercises will appear in blue boxes like this one. You should perform them in the interactive interpreter, unless otherwise stated.

   If you prefer to use the IPython notebook (which we recommend!), perform your exercises in the notebook and save it when you are done. Submit the ``.ipynb`` file to your trainer when you finish.

   For command line IPython or the ``python`` interactive interpreter, you should copy your input and the interpreter's output to a text file. At the end of the training, submit the text file with your exercise solutions to your trainer.

.. _python_dtype:

Built-In Data Types
===================

The principal built-in types of Python are numerics, sequences,
mappings, files, classes, instances and exceptions. Other data types are
available through importing modules (Example: the datetime module).

Numeric types
-------------

There are four distinct numeric types in Python:

- plain integers, or "ints"
- long integers, or "longs" (specified with an ``L`` suffix, or created automatically)
- floating-point numbers, or "floats" (which have ``double`` precision, in C terms)
- complex numbers, or "complexes", which are composed a floating point real and imaginary part (e.g. ``1.2 + 3.4j``)

The Python interpreter will try to do "the right thing" when you operate on numeric values with different types.

If a sum exceeds the maximum value a "plain integer" can represent, the result will be a long integer. When doing arithmetic with integers and floating point numbers, the result will always be floating point. When complex numbers are added to the mix, the result will always be complex. ::

   >>> 1 + 1
   2
   >>> 1 + 1L
   2L
   >>> 1 + 1.0
   2.0
   >>> 1 + (1.0 + 0.0j)
   (2+0j)

You can explicitly convert a variable from one type to another using the "short names" above::

   >>> int(3.5)  # note: this doesn't "round up"!
   3
   >>> long(3)
   3L
   >>> float(3)
   3.0
   >>> complex(3)
   3+0j

.. warning::

   One "gotcha", corrected in Python 3, is that dividing two integers will discard the fractional part.

      >>> 5 / 2 == 2.5
      False
      >>> 5 / 2
      2

   To get a floating-point result, ensure that one or both operands is a float.

      >>> 7.0 / 3
      2.3333333333333335
      >>> float(7) / 3
      2.3333333333333335

   In the (unlikely?) event that you want the integer division behavior, use the ``//`` operator to ensure the meaning of your code does not change when run on newer versions of Python. ::

      >>> 7 // 3
      2

   See :ref:`python_3_vs_2` for details.

Boolean types and expressions
-----------------------------

Any expression that can be interpreted as a boolean value can be used in an ``if``/``elif`` statement, ``while`` loop test, or other places boolean values are needed.

Equality/inequality statements are perhaps the most common and useful. The operators are ``<``, ``>``, ``>=``, ``<=``, ``==``, ``!=`` (not like in IDL or FORTRAN, where comparisons are done with shortened keywords like ``eq``). These work for numeric types (except complex numbers, which have no ordering relation)::

   >>> 3 < 4.0
   True
   >>> 3 >= 3.0
   True
   >>> 3 == 3.0
   True

String types can also be compared in this way, but that's more of a curiosity than something you will regularly need. The following is equivalent to asking if "JWST" comes after "Hubble" alphabetically::

   >>> "JWST" > "Hubble"
   True

For strings, you usually want to identify when they are different from each other (or equal)::

   >>> "Hubble" != "Hubble"
   False
   >>> "JWST" == "JWST"
   True

Combining conditions is done with the boolean operators ``and`` and ``or``, and negation with ``not``::

   >>> not "science" in "JWST"
   True
   >>> "ST" in "STScI" and 3 > 4.0
   False
   >>> "science" in "JWST" or 3 == 3.0
   True

These boolean operators in Python are what is called "short-circuiting". This means that if Python can determine the truth value of ``expr1 and expr2`` or ``expr1 or expr2`` from the value of ``expr1`` alone, it will not evaluate ``expr2`` at all. You can use this to your advantage, for example when ``expr2`` takes a long time to compute::

   >>> True or compute_ten_thousand_factorial() > 1000000
   True
   >>> False and compute_ten_thousand_factorial() > 1000000
   False

In the first expression, Python won't bother computing ten-thousand factorial, since the expression must be True regardless. In the second, the expression must be False regardless.

.. note::

   **What about &&, ||, !, ~, &, and |?**

   If you've programmed in a C-like language before, you're probably used to ``&&``, ``||``, and ``!`` in your boolean expressions. Good news: Python ``and``, ``or``, and ``not`` work just like them.

   C-like languages have the notion of *bitwise* operators like ``~`` (complement), ``&`` (bitwise and), and ``|`` (bitwise or). Those operators exist in Python, but are reserved for "special occasions". (We will see an example later on with NumPy arrays, where you can use ``&`` and ``|`` to filter a data set in sophisticated ways.)

.. _python_different_sequences:

Different kinds of sequences in Python
--------------------------------------

Python provides three main built-in sequence types: ``tuple``, ``list``, and ``str``. Lists are variable-length collections of entries that need not all be the same data type, and tuples are their immutable (i.e. non-modifiable) cousins. We have seen strings (``str``) in the section on comparisons, but it bears mentioning that they are immutable sequences that support indexing and slicing like tuples.

To make a new tuple, you need parentheses and a comma::

   >>> ('first element', 'second element')
   ('first element', 'second element')
   >>> type(('first element', 'second element'))
   <type 'tuple'>

There's no requirement that all elements in a sequence have the same data type. Imagine a tuple describing a dataset by filename, extension number, and mean pixel value::

   >>> mydataset = ('icft01crq_raw.fits', 1, 340.0)

This tuple contains a string, an integer, and a floating point number without any special treatment on the part of the programmer. (If you're used to interpreted scripting languages, this is probably not very novel or exciting.)

.. tip::

   This example assigns a new variable named ``mydataset`` with the ``=``. The single equals sign is always assignment, in contrast with the double equals sign which tests equality.

Tuples, like most sequences you'll see in Python, have a defined length, which you can check with the ``len()`` function::

   >>> len(('first element', 'second element'))
   2

Indexing into sequences uses square brackets. Consider a tuple of integers, assigned to a new variable called ``mynumbers``. Accessing its elements would look like this::

   >>> mynumbers = (4, 8, 1, 2, 9, 3, 4, 7, 5)
   >>> mynumbers[0]
   4
   >>> mynumbers[3]
   2
   >>> mynumbers[-1]
   5

In Python, indexes count from zero (the first element is element 0, the second is element 1, etc.). For most sequence types in Python, it is legal to use negative numbers to index counting back from the end (element ``-1`` is the last, ``-2`` second-to-last, etc.).

There's no requirement that your index be a literal number, either. This is perfectly valid::

   >>> index = 3
   >>> mynumbers[index]
   2

Slicing up a sequence
^^^^^^^^^^^^^^^^^^^^^

Python supports the concept of a "slice" of a sequence with the ``:`` symbol inside the indexing brackets. The syntax ``mynumbers[start:stop]``, where ``start`` and ``stop`` are integers, tells Python you want the items ``mynumbers[start]``, ``mynumbers[start + 1]``, ... , ``mynumbers[stop - 1]``.

An example may be more illustrative::

   >>> mynumbers = (4, 8, 1, 2, 9, 3, 4, 7, 5)
   >>> mynumbers[2:5]
   (1, 2, 9)

Recall that Python is zero-indexed, so we're asking for the third through fifth elements. (Why isn't it ``[2:4]``? Well, one reason is so that ``len(mynumbers[2:5]) == 5 - 2``, but really it's just a decision the language designers made.)

You can omit the ``start``... ::

   >>> mynumbers[:5]
   (4, 8, 1, 2, 9)

... or the ``stop``::

   >>> mynumbers[2:]
   (1, 2, 9, 3, 4, 7, 5)

Those are the basics. There are more slicing tricks like the extra ``:step`` syntax, negative step sizes, and multi-dimensional indexing that we'll leave for you to discover as you learn Python.

Multiple assignment with sequences
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sequences can also be used on the right hand side of an assignment operation. Suppose we want to break our ``mydataset`` tuple from before into its constituent pieces (filename, extension, mean value)::

   >>> mydataset = ('icft01crq_raw.fits', 1, 340.0)
   >>> filename = mydataset[0]
   >>> extension = mydataset[1]
   >>> mean = mydataset[2]
   >>> print filename
   icft01crq_raw.fits
   >>> print extension
   1
   >>> print mean
   340.0

.. warning::

   In Python 3, the statement ``print mything`` will be written as a function call like ``print(mything)``!

   See :ref:`python_3_vs_2` for details.

That's a bit verbose. As long as we know the number of elements we're getting, Python lets us do this instead::

   >>> filename, extension, mean = mydataset
   >>> print filename
   icft01crq_raw.fits
   >>> print extension
   1
   >>> print mean
   340.0

.. _python_immutable_tuples_mutable_lists:

Immutable tuples vs. mutable lists
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

What happens if we try to go the other way, and assign something to the third position?

   >>> mydataset[2] = 199.9
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: 'tuple' object does not support item assignment

This is what is meant when we say tuples are "immutable". There are good reasons you might want to have immutable data, but when you need to be able to modify a sequence in-place you need a **list**.

To write a new list in your code, use a comma-separated sequence of values enclosed in square brackets. For example::

   >>> mydataset_list = ['test.fits', 1, 100.0]

Let's try assigning to position ``2`` again::

   >>> mydataset_list[2] = 199.9
   >>> print mydataset_list
   ['test.fits', 1, 199.9]

Lists implement all of the behaviors described above for tuples, but additionally support modification in place with *assignment* (as shown above) and with *methods* that manipulate a particular list variable. We'll look at three of the most commonly used methods, but a full reference is available :py:ref:`in the Python reference manual <python:typesseq-mutable>`.

Let's start with a list of floating point values. Pretend they're PSF encircled energies, or something.

   >>> psf_ee_vals = [0.101, 0.413, 0.219, 0.713]

Appending to a list
^^^^^^^^^^^^^^^^^^^

``append()`` appends the argument to the end of the list.

   >>> psf_ee_vals.append(0.99)
   >>> psf_ee_vals
   [0.101, 0.413, 0.219, 0.713, 0.99]

Popping items off a list
^^^^^^^^^^^^^^^^^^^^^^^^

``pop()`` removes the last item in the list and returns it (so that you can keep the result).

   >>> last_val = psf_ee_vals.pop()
   >>> last_val
   0.99
   >>> psf_ee_vals
   [0.101, 0.413, 0.219, 0.713]

.. tip::

   In addition to being the notional "inverse" of ``append()``, ``pop()`` can be called with an integer index specifying which element to "pop out" of the sequence. (e.g. To remove the first element, you could do ``psf_ee_vals.pop(0)``.)

Sorting a list
^^^^^^^^^^^^^^

``sort()`` sorts a list in-place, meaning it does not return anything. However, when you access the list again, it will be reordered least-to-greatest. (n.b. This is only meaningful if your list elements are all the same data type.)

   >>> psf_ee_vals.sort()
   >>> psf_ee_vals
   [0.101, 0.219, 0.413, 0.713]

Deleting an item
^^^^^^^^^^^^^^^^

Deleting is actually *not* a method of a list (surprise!), but rather a language keyword called ``del``. Use it with an expression referring to a list item to delete it.

   >>> del psf_ee_vals[-1]
   >>> psf_ee_vals
   [0.101, 0.219, 0.413]

.. tip::

   You can also use ``del`` on any variable name to clear that reference to it. This is less useful than you might think, since Python manages memory for you and won't actually free the memory until all references have been collected. ::

      >>> a = ['a', 'b']
      >>> b = a
      >>> del a
      >>> a
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
      NameError: name 'a' is not defined
      >>> b
      ['a', 'b']

   In practice, you will rarely need to use ``del``, but we include it for completeness' sake.

.. admonition:: Exercise
   :class: note

   Write a snippet of code that starts with a list ``[0.101, 0.413, 0.219, 0.713]``. Remove the smallest value, add a new value of your choosing, and print a sorted list as your final result.

Operating on sequences with loops
---------------------------------

If you've programmed in other languages before, you are probably familiar with looping over a sequence using a "loop variable" that counts from 0, 1, 2, ... up to the last element in your sequence. In Python, that's possible, but there's a shortcut::

   >>> mytuple = ('first element', 'second element')
   >>> for item in mytuple:
   ...     print item
   ...
   first element
   second element

Here we've introduced our first use of an indented block. See how the ``print`` line is indented four spaces following the ``for item in mytuple:`` line? Currently we're just printing the current item at each iteration of the loop, but more lines of code can be added as long as the indentation is maintained. Within the indented block, the name ``item`` takes on the value of the current item in the sequence.

.. warning::

   If you're using a list or other mutable sequence, don't alter the sequence within the loop body! You may experience unexpected behavior.

There **are** cases where you might want the "loop variable" giving the numerical index of each item explicitly. For that, wrap your sequence in the ``enumerate()`` helper function::

   >>> mytuple = ('first element', 'second element')
   >>> for idx, item in enumerate(mytuple):
   ...     print idx, item
   ...
   0 first element
   1 second element

Note how the first expression after the for keyword now reads ``idx, item`` instead of ``item``. When looping with an "enumerated" sequence, the index and item are provided to the loop body as a pair. [#iterationtuple]_

List comprehensions
^^^^^^^^^^^^^^^^^^^

A very common pattern in Python is having a list (or other sequence) and creating a new list by applying some operation to each element. ::

   >>> mysequence = ['first', 'second', 'third', 'fourth']
   >>> newsequence = []
   >>> for item in mysequence:
   ...     newitem = item.upper()
   ...     newsequence.append(newitem)
   ...
   >>> newsequence
   ['FIRST', 'SECOND', 'THIRD', 'FOURTH']

To simplify things, Python has a structure called a "list comprehension". List comprehensions are introduced with the same square brackets as list literals (that is, lists created like ``a = [1, 2,3]``). Rather than a comma separated sequence, they instead have special syntax for a loop.

The above code listing would look like this in list comprehension form::

   >>> mysequence = ['first', 'second', 'third', 'fourth']
   >>> newsequence = [item.upper() for item in mysequence]
   >>> newsequence
   ['FIRST', 'SECOND', 'THIRD', 'FOURTH']

You may even apply a condition to the item within the list comprehension. For example, the following two code samples are equivalent. First with a loop block::

   >>> mysequence = ['first', 'second', 'third', 'fourth']
   >>> newsequence = []
   >>> for item in mysequence:
   ...     if item != 'second':
   ...         newitem = item.upper()
   ...         newsequence.append(newitem)
   ...
   >>> newsequence
   ['FIRST', 'THIRD', 'FOURTH']

And second with a list comprehension::

   >>> mysequence = ['first', 'second', 'third', 'fourth']
   >>> newsequence = [item.upper() for item in mysequence
   ...                if item != 'second']
   >>> newsequence
   ['FIRST', 'THIRD', 'FOURTH']

.. tip::

   We're taking advantage of the fact that Python allows you to continue to the next line within parentheses or brackets. The ``if item != 'second']`` part of the list comprehension is indented for ease of reading.

Strings
-------

Textual data in Python lives in strings, which are usually enclosed in either single or double quotes. If a string spans multiple lines, triple quotes (``'''`` or ``"""``) are used.

   >>> 'hello world'
   'hello world'
   >>> "hello world"
   'hello world'
   >>> """hello
   ... world"""
   'hello\nworld'
   >>> '''hello
   ... world'''
   'hello\nworld'

(The ``\n`` in the triple-quoted examples represents the linebreak.)

A string is, in some ways, a lot like the tuples we just saw. For instance, they are immutable::

   >>> mystring = 'JWST'
   >>> mystring[0] = '?'
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: 'str' object does not support item assignment

They also support indexing and slicing::

   >>> mystring[2:]
   'ST'

However, they have a few additional capabilities you may find useful. The ``in`` keyword, for example, will test if one string is contained within another::

   >>> "science" in "JWST"
   False
   >>> "ST" in "STScI"
   True

Even though you cannot modify a string in-place, you can stick two together with the ``+`` operator::

   >>> "ST" + "ScI"
   'STScI'

Or use ``+=`` to add and reassign in a single step::

   >>> name = "ST"
   >>> name += "ScI"
   >>> name
   'STScI'

Strings also have some string-specific helper methods, as we shall see.

Splitting strings on a delimiter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``.split()`` splits a string at every instance of the delimiter string passed as the first argument. (A delimiter is just a character or string of characters that separates pieces of data in a sequence, like a comma.)

For example, say we have a target catalog::

   RA,Dec,Mag,Name,Shortname,K2ID
   093.479095,26.882500,18.0,K 3-71,k371,202065169
   095.420833,23.586944,19.0,HoCr 1,hocr1,202065170
   096.488487,17.790980,17.8,J900,j900,202060054

Let's take one line of it, and split it at every occurrence of the comma, ``,``::

   >>> catalog_line = "096.488487,17.790980,17.8,J900,j900,202060054"
   >>> catalog_line.split(',')
   ['096.488487', '17.790980', '17.8', 'J900', 'j900', '202060054']

As you can see, now we have a list with the catalog entry split up by column.

It's also possible to call ``split()`` with *no* argument, which makes it split on "white space" (spaces and tabs). Suppose our catalog columns were lined up with spaces::

   >>> catalog_line_space_delim = "096.488487  17.790980  17.8      J900   j900  202060054"
   >>> catalog_line_space_delim.split()
   ['096.488487', '17.790980', '17.8', 'J900', 'j900', '202060054']

Joining a sequence with a string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Joining is the opposite of splitting. However, it is a method of *strings*, not of sequences. It's probably easiest to explain by example. Here, we split the catalog line up by its commas, and join it back together with semicolons::

   >>> catalog_line = "096.488487,17.790980,17.8,J900,j900,202060054"
   >>> parts = catalog_line.split(',')
   >>> parts
   ['096.488487', '17.790980', '17.8', 'J900', 'j900', '202060054']
   >>> ';'.join(parts)
   '096.488487;17.790980;17.8;J900;j900;202060054'

That called the ``.join()`` method on the string ``';'`` to produce a new string with the parts joined by semicolons.

Substituting numeric and other values into a string
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There's a surprising amount of complexity wrapped up in the ``.format()`` method of strings. For the purposes of an introduction, we'll only scratch the surface. When substituting values into strings, there is a "format string" that acts as a template. It contains symbols indicating where the substitutions should go.

The simplest case is substituting strings into a format string, like if we wanted a prettier display of ``parts`` from the previous section.

   >>> '{} -- Kepler mag = {}'.format(parts[3], parts[2])
   'J900 -- Kepler mag = 17.8'

You may also see ``{0}``, ``{1}``, etc. used as placeholders. The numbers indicate which argument to ``.format()`` should go where, and are used if that differs from the order in which they were supplied.

   >>> 'second: {1}, first: {0}'.format(3.5, 9.8)
   'second: 9.8, first: 3.5'

The last essential thing to know about string formatting is how to make decimal numbers behave. ::

   >>> '1 / 3 is approximately {}'.format(1.0 / 3.0)
   '1 / 3 is approximately 0.333333333333'

Suppose we only wanted the first two digits after the decimal point. We use a "format specifier" to tell the ``.format()`` method how it should look. Here, it's ``:.2f`` meaning "two places after the decimal point, floating point format"::

   >>> '1 / 3 is approximately {:.2f}'.format(1.0 / 3.0)
   '1 / 3 is approximately 0.33'

.. admonition:: Exercise
   :class: note

   Using the ``catalog_line`` variable from the examples, and what you now know about string formatting, print out a nicely formatted summary of the RA, Dec, Mag, and Name columns.

   (Keep in mind that the parts you get from ``.split()`` are strings, not numbers! If you want to get fancy formatting the numeric values, you'll have to use something like ``float(mypart[0])`` to convert them to a numeric type *before* you pass them to ``.format()``.)

.. _python_dictionaries:

Dictionaries
------------

A dictionary maps keys to values, but unlike lists and tuples it has **no ordering**. You may have seen this data type by another name; they're sometimes called "hashes", "hashmaps", "maps", or "associative arrays".

To write a dictionary in your code, use a sequence of ``key: value`` pairs separated by commas, and enclosed in curly braces (``{}``). Say we want to map filter names to center wavelengths. The "keys" in this case would be the filter names, and the "values" would be the center wavelengths in meters. ::

   >>> filters = {"F212N": 2.12e-6, "F110W": 1.1e-6, "F460M": 4.6e-6}

There's no rule that keys have to be strings, as long as they are unique [#hashable]_ . You can't have two different center wavelengths for ``"F212N"``, for example. To access the values, supply the key within square brackets (like you would for list indexing)::

   >>> filters['F212N']
   2.12e-06

If you try to access a key that is not present in the dictionary, you will get an exception (that is, an error that aborts what your program is currently doing)::

   >>> filters['F335M']
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   KeyError: 'F335M'

You can check if a key is present in a dictionary first without triggering an exception::

   >>> 'F335M' in filters
   False
   >>> 'F212N' in filters
   True

If you don't know whether a key will be present, but you have a "default" value you want to use when a key is absent, use the ``.get()`` method::

   >>> filters.get('F212N', 'Missing')
   2.12e-06
   >>> filters.get('F335M', 'Missing')
   'Missing'

When no second argument is supplied, and the key is not found, you'll get the special value ``None``::

   >>> filters.get('F335M')
   >>> filters.get('F335M') is None
   True

.. tip::

   In Python, ``None`` is used to indicate when something is absent (when absence should not be treated as an error). To test for it in your programs, ``expr is None`` is preferred to ``expr == None``.

Once you've made a dictionary, you can add new keys to it using the ``=`` assignment operator::

   >>> filters['F227W'] = 2.27e-6
   >>> filters
   {'F212N': 2.12e-06, 'F227W': 2.27e-06, 'F110W': 1.1e-06, 'F460M': 4.6e-06}

And, similarly to lists, the ``del`` keyword removes an entry::

   >>> del filters['F227W']
   >>> filters
   {'F212N': 2.12e-06, 'F110W': 1.1e-06, 'F460M': 4.6e-06}

The last important thing you might want to do with your dictionary is iterate over its key value pairs::

   >>> for key, val in filters.items():
   ...     print key, 'is', val
   F212N is 2.12e-06
   F110W is 1.1e-06
   F460M is 4.6e-06

(n.b. In this example, we used commas so that multiple arguments to the ``print`` statement would print out with spaces between them.)

One thing that trips up a lot of new Python users is that dictionaries have **no ordering** of their elements. When you loop over ``.items()``, you might get the keys in alphabetical order, order of assignment, or totally randomly! If you need to preserve ordering, use a sequence type like a list or tuple.

.. admonition:: Exercise
   :class: note

   You now know about lists, tuples, and dictionaries. Combine what you know to represent this target catalog using dicts and sequences.

   ::

      RA,Dec,Mag,Name,Shortname,K2ID
      093.479095,26.882500,18.0,K 3-71,k371,202065169
      095.420833,23.586944,19.0,HoCr 1,hocr1,202065170
      096.488487,17.790980,17.8,J900,j900,202060054

   Your solution to this exercise should be in the form of a variable declaration ``catalog = ...`` followed by a data structure made up of lists, dictionaries, and/or tuples. (In other words, you don't need to *generate* this data structure from the catalog for this exercise. Writing it out by hand is fine.)

   (Hint: What type should the ``catalog`` variable be? What type(s) should its contents be? If there are dictionaries, what are their keys?)

.. _python_file_operations:

Lower-level file operations
---------------------------

Later on, we will see how to read in text tables and FITS files with Astropy. However, sometimes you will have a file that is not readable with those techniques, and you will have to use Python's built-in file operations to handle it.

We'll be using the target catalog introduced in the previous section. Copy the file ``k2_catalog.csv`` from ``/grp/hst/riab/training/python`` to your working directory.

The "old" way to open a file was to use ``open()``. By default, ``open(filename)`` only supports reading, not writing. ::

   >>> myfile = open('k2_catalog.csv')

At this point, nothing has been read in, but ``myfile`` provides a reference (sometimes called a "handle") to the file. Since this file is broken up into lines, we read it in with ``myfile.readlines()``::

   >>> lines = myfile.readlines()
   >>> lines
   ['RA,Dec,Mag,Name,Shortname,K2ID\n',
    '093.479095,26.882500,18.0,K 3-71,k371,202065169\n',
    '095.420833,23.586944,19.0,HoCr 1,hocr1,202065170\n',
    '096.488487,17.790980,17.8,J900,j900,202060054\n']

Now that we have read our data into the new ``lines`` list variable, we make sure to **close** the file with ``myfile.close()``::

   >>> myfile.close()

A closed file cannot be read from any more, and has an **attribute** called ``closed``. You access the attribute with a dot, but no parentheses::

   >>> myfile.closed
   True

Leaving file handles open can cause problems with long-running scripts, especially if you open a great many files. In response to this fact, and the tendency of programmers to forget to close their file handles, Python introduced the ``with`` keyword.

The "old" style example above can be written as follows with the ``with`` keyword::

   >>> with open('k2_catalog.csv') as myfile:
   ...     lines = myfile.readlines()
   ...
   >>> lines
   ['RA,Dec,Mag,Name,Shortname,K2ID\n',
    '093.479095,26.882500,18.0,K 3-71,k371,202065169\n',
    '095.420833,23.586944,19.0,HoCr 1,hocr1,202065170\n',
    '096.488487,17.790980,17.8,J900,j900,202060054\n']

In this example, Python automatically closes ``myfile`` once we end the ``with`` block. Check the ``closed`` attribute to verify::

   >>> myfile.closed
   True

Limitations of ``readlines``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For the purposes of our example, ``.readlines()`` was the easiest way to read in the whole catalog. However, for files that are too big to fit in RAM, your program's performance will suffer. Python provides a way to operate on files one line at a time, without loading the whole thing into memory.

Imagine your ``k2_catalog.csv`` were actually several gigabytes of target data, and we only wanted the line for J900. Using ``for ... in ...`` to iterate over the ``myfile`` object, Python will not try to load the whole file into RAM first.

   >>> with open('k2_catalog.csv') as myfile:
   ...     for line in myfile:
   ...         if 'J900' in line:
   ...             print line
   096.488487,17.790980,17.8,J900,j900,202060054

Also, it bears mentioning, both ``.readlines()`` and ``for ... in fileobject`` will only help you when your file is "plain text" broken up into lines. Reading binary files with ``open()`` is an advanced topic, but Python can do that just as well. See :ref:`python:tut-filemethods` in the official Python tutorial for more details on file objects.

Objects, Instances, Attributes, Functions, and Methods
======================================================

Python is an object oriented programming language and before we go any
further, it is important to note the differences and uses of objects,
instances, attributes, functions, and methods.

-  Objects:

   Data carriers that also carry functions and attributes that work on
   that data. In :ref:`python_dtype`, integers, floats, lists, tuples, and
   dictionaries are all objects.

-  Instance:

   In :ref:`python_dictionaries` when we said ``filters = { ... }`` we created
   an instance of a dictionary, ``filters``. Similarly, while ``myfile``
   was an instance of a ``file`` object created with ``open()``.

-  Attributes:

   For example: ``closed`` is an attribute of an instance of a Python file.
   In :ref:`python_file_operations` we used ``myfile.closed`` to check if the ``myfile`` instance had been closed.
   Attributes do not have the '()' like functions or methods do.

-  Functions:

   A function is a named piece of code that can be run by "calling" it. To call a function, place parentheses after the name. If a function operates on values, those go inside the parentheses and are called "arguments". If the function produces a result, that is its "return value", which can be assigned to a variable.

   ``len()`` is a function, and in :ref:`python_different_sequences` we pass it the
   tuple ``('first element', 'second element')``.

-  Methods:

   A method is a function attached to an object that then has access
   to all other methods and attributes of that object. Therefore we
   usually do not have to pass as much information to methods, and
   methods are easier to read. All methods are functions, but not all
   functions are methods.

   For example, in :ref:`python_immutable_tuples_mutable_lists`, after we
   created the instance ``psf_ee_vals``, we append a number to that list
   using the :ref:`append() <python:tut-morelists>` method with the line ``psf_ee_vals.append(0.99)``.

   In :ref:`python_file_operations` we also used the methods ``readlines()`` and ``close()``
   which belong to the ``file`` class.

Notice that we use dot notation to call an attribute or a method of a
particular instance. As we will see in :ref:`python_modules`, dot notation
will also be used to call a method or a function from a particular
module.

Double Underscore
=================

In Python you will notice certain names beginning and ending with double
underscores. These names are used for attributes and methods that are
used or created by the interpreter (for a discussion on the definition
of attributes and methods see Section [s:attribute]). Examples include:

-  ``__file__`` : an attribute automatically created by the interpreter

-  ``__add__`` : an attribute with special meaning to the interpreter

-  ``__init__`` : a method implicitly called by the interpreter, defined
   by the programmer

We will see examples of a few of these in :ref:`python_scripts`.

Common Built-In Functions and Statements
========================================

For a complete list of Python built-in modules, see
http://docs.python.org/library/index.html, also listed in
:ref:`python_links`. Below we provide descriptions of some of the most
useful functions and statements.

print function
--------------

**Use:** The print function performs formatted output.

Examples::

   >>> a = 3
   >>> print a
   >>> b = 2
   >>> print a + b
   >>> print a / b
   >>> b = 2.
   >>> print a / b
   >>> c = 'hi'
   >>> print c + ' there'
   >>> print 'I brought home {} flowers for \
   ...    ${} and all she said was {}.'.format(a,b+0.5,c)

This last statement is a bit more complicated. The ``{}`` symbol says to
insert a variable from one of the arguments we give at the end. In the
brackets we could specify data type, or which variable (0, 1, or 2), but
we left it as default, which just takes the next argument in line.
Notice the float does not print out exactly as we want. We would rather
it say $2.50. Try this::

   >>> print 'I brought home {} flowers for ${:.2f} and all \
   ... she said was {}.'.format(a, b+0.5, c)

In this last example the 'f' stands for 'float', and the '.2' says to include two decimal places. For more information see: http://docs.python.org/library/string.html#formatstrings.

.. admonition:: Exercise
   :class: note

   Print out your own creative sentence.

help() function
---------------

**Use:** The help() function gives the user information on many aspects of the
current Python session. Type 'q' to quit.

Examples::

   >>> a = 3
   >>> help(a)

.. admonition:: Exercise
   :class: note

   Type ``help()`` and explore the options.

range() function
----------------

**Use:** The range() function creates a list starting at zero of the length you
give it. You may also pass the start, stop, and the step you want to use
(default of the step is 1).

Examples::

   >>> range(4)
   >>> range(2, 8, 2)

See also:

Other useful similar functions in NumPy (see :ref:`python_numpy`) are
numpy.linspace.

dir() function
--------------

**Use:** The dir() function returns the methods and attributes of an object.

Examples::

   >>> a = range(10)
   >>> dir(a)

len()  function
---------------

**Use:** The len() function returns the number of elements contained in an
expression or variable.

Examples::

   >>> a = range(11)
   >>> len(a)

See also:

Other useful similar functions in NumPy (see :ref:`python_numpy`) are
numpy.shape, numpy.size.

for loop
--------

**Use:** The for statement is used to execute one or more statements
repeatedly.

Examples::

   >>> a = range(11)
   >>> for x in a: print x
   >>> b = ['2005', '2006', '2007']
   >>> for x in b: print x + '-01'

One can create a list with a for loop in one line. This is known as list
comprehension. ::

   >>>  c = [x*2 for x in range(11)]

See also:

Other useful similar statements are ``if``, ``elif``, ``else``, ``while``.


.. admonition:: Exercise
   :class: note

   Create a list with 10 values equal to the square of the index.

.. admonition:: Exercise
   :class: note

   Create the following sequence using a for statement: 2001-01-01, 2001-02-01, 2001-03-01, 2001-04-01.

xrange() function
-----------------

**Use:**

The xrange() function is similar to range() except that it does not
create a new list (saving on memory) but instead acts as a generator of
numbers starting at zero up to the stop value you pass it. You may also
pass the start, stop, and the step you want to use (default of the step
is 1). This is used in iterations.

Examples::

   >>> for x in xrange(3): print x, x * 2

Within a function, the for statement has the following simple structure:

   >>> for x in xrange(1, 7):
   ...    a = x * 3.0
   ...    print a

See also:

Other useful similar statements are range().

Notice that we use range() when we use the actual list created, but
xrange() when we just need an iterator.

try ... except statement
------------------------

**Use:** The try ... except statement is used as an error handler. It will try
whatever we put in the try block, but if whatever you assign as the
'error' occurs, it will go to the except block.

Examples: Try this code below. Notice the error message you get. ::

   >>> a = [1, 2, 3, 4, 5]
   >>> for i in xrange(len(a)):
   ...    a[i + 1] = 100 + a[i]
   ...    print a[i], a[i + 1]

To solve this problem, we put it in a try ... except statement::

   >>> a = [1, 2, 3, 4, 5]
   >>> for i in xrange(len(a)):
   ...     try:
   ...         a[i + 1] = 100 + a[i]
   ...         print a[i], a[i + 1]
   ...     except IndexError:
   ...         print 'This index does not work: ',i + 1

.. admonition:: Exercise
   :class: note

   Imagine a situation where your code passes a function a variable, and
   that variable might be zero. The only problem is that this function
   divides by that variable.

   Write a simple loop which calculates 1/\ :math:`n`, where :math:`n` is a
   number in range(11). What happens when :math:`n=0`? Write an error
   handling for this loop (hint: use try ... except statement with
   ZeroDivisionError).

.. _python_modules:

Importing Modules, and Common Functions
=======================================

Python's built-in functions are limited. The diversity of Python's
abilities come when we import modules. The following syntax can be used:

   >>> import <module>
   >>> from <module> import <function_in_module>
   >>> import <module> as <short_name>

math.sqrt() function
--------------------

**Use:** If we want to take the square root of a number, we could use the
function sqrt() in the module math. The following is two examples of how
to do this:

Examples::

   >>> import math
   >>> math.sqrt(100)

Notice we did not need the '.py' extension. If we do not need any other
math module, and we know we will not name a variable 'sqrt' and
overwrite the function, we can do this::

   >>> from math import sqrt
   >>> sqrt(100)

glob.glob() function
--------------------

**Use:** The glob.glob() function searches for files that match the given
path-name. The path-name you give is a string similar to the search
strings used for the UNIX/Linux 'ls'. A list is returned containing any
matching files.

Examples::

   >>> import glob
   >>> glob.glob('*')
   >>> glob.glob('*.pdf')
   >>> datadir = '/grp/hst/riab/training/python/'
   >>> glob.glob(datadir + 'flux_vs_time_?.fits')

.. admonition:: Exercise
   :class: note

   Search for a set of files on your desktop.

random.random() function
------------------------

**Use:** The random.random() function returns a random floating point number in
the range [0.0, 1.0).

Examples::

   >>> import random
   >>> random.random()
   >>> print 'My random number between 2 and 8: ', \
   ...    2 + (8-2) * random.random()

See also:

Other useful similar statements are random.uniform(), random.gaus().

re.search() function
--------------------

**Use:** The re module is for 'Regular Expression' operations. It is used to
work with strings, including sophisticated pattern matching, as in the
case of re.search().

Examples::

   >>> import re
   >>> m = re.search('(?<=_)\d+','MIRI_2011.fits')
   >>> m.group(0)

In the above example we are looking for digits following an underscore,
'\_'. The '\\d' is for digit, and the '+' is for one or more. The '(?<=_)' matches if the position in the string is proceeded by '_'.

See also:

Other useful similar statements are re.match().

os.getcwd() and os.chdir() functions
------------------------------------

**Use:** The os module is for 'Operating System' operations. Examples include
os.getcwd() which returns the current working directory and os.chdir()
which changes the current working directory.

Examples::

   >>> import os
   >>> datadir = '/Users/username/data/'  #insert a usable path
   >>> mydir = os.getcwd()
   >>> if (mydir != datadir): os.chdir(datadir)

See also:

Other useful similar statements are os.open(), os.close().

sys.exit() function
-------------------

**Use:** The sys module is for system-specific parameters and functions. It
provides a way to interact with the interpreter. sys.exit() is different
than exit() in that it will honor try statements and you can intercept
the exit attempt.

Examples::

   >>> import sys
   >>> for i in xrange(10):
   ...        if i <= 5:
   ...            continue
   ...        else:
   ...            sys.exit('We do not need a number above 5.')

.. _python_numpy:

NumPy and Data Arrays
=====================

The Uses of NumPy
------------------

NumPy is a Python module which adds support for large, multi-dimensional
arrays and matrices, along with a large library of high-level
mathematical functions to operate on these arrays. NumPy addresses the
problems of speed in interpreted languages by providing
multi-dimensional arrays and lots of functions and operators that
operate on arrays. Any algorithm that can be expressed primarily as
operations on arrays and matrices can run almost as fast as the
equivalent C code.

NumPy's array vs. Python's built-in list
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

NumPy introduces new data types, but the most popular, versatile, and
useful one is the array. This is similar to arrays in IDL. There are
several reasons why you would want to use a NumPy array over Python's
built-in list.

-  NumPy, PyLab, SciPy, PyFITS and other modules' functions often work
   with NumPy arrays.

-  Every item in a NumPy array is of the same data type. This means
   there is less information to keep track of which makes array
   computations faster.

-  NumPy arrays act as vectors and therefore we can do things such as
   element-wise addition and multiplication.

To convert a list to an array, use numpy.array().

numpy.array() function
^^^^^^^^^^^^^^^^^^^^^^

**Use:** The numpy.array() function converts a list to a NumPy array.

Examples::

   >>> import numpy as np
   >>> a = [1,2,3,4]      #a Python built in list
   >>> b = np.array(a)     #converted to a NumPy array
   >>> print a
   >>> print b
   >>> indx = [1,2]
   >>> print b[indx]
   >>> print b[1:3]       #prints elements 1 to 2, NOT 1 to 3.
   >>> print b[:3], b[3:] #prints up to the 3rd element, \
   ...    and then everything after the 3rd element.
   >>> print b[-1],b[-2]
   >>> print b[::-1]      #reverses the array.
   >>> c = np.array([[1,2,3,4,5],[6,7,8,9,10]])
   >>> print c
   >>> print c[1,3]       #indices for a multi-dimensional array
   >>> print c[1][3]      #this is slower than the previous as it \
   ...    creates a new array, c[1], and then subscripts that array.
   >>> print c[1,:]  #print the first element in the first \
   ...    dimension, but all in the second dimension
   >>> print c[:,1]

Notice when we print lists and arrays that the elements in lists are
separated by commas while the elements in arrays are only separated by
spaces.

.. admonition:: Exercise
   :class: note

   Create a list ``a`` and a NumPy array ``b``. Multiply each by 2
   and explain what happens. Now add 2 to each array. Again, explain the
   result.

.. admonition:: Exercise
   :class: note

   Create a third list ``c``. Add ``c`` to both ``a`` and
   ``b``. Explain the result.

What a NumPy array really is and a word of caution
--------------------------------------------------

A final note about NumPy arrays is that an array is actually an object
which points to a block of memory. For example, in the above exercise we
created an array ``b``. Try the following::

   >>> d = b

Now we just created a second array, ``d``. Instead of using up twice
the memory space, ``d`` is just a pointer to the memory ``b``
also points to (remember, we copied an array, and an array is a
pointer). Again, try the following::

   >>> d[2] = 999
   >>> print d
   >>> print b

Notice what happened to ``b``. While it saves on memory space,
programmers have to be careful. If you know you will want to change one
array and not the other, the correct function to use is numpy.copy().

numpy.copy() function
^^^^^^^^^^^^^^^^^^^^^

**Use:** The numpy.copy() function copies the contents of the memory space the
array points to.

Examples: Try the code below and notice the difference in the results from a
simple ``d = b`` assignment. ::

   >>> import numpy as np
   >>> a = np.array([1,2,3,4,5,6,7])
   >>> b = a.copy()
   >>> b[2] = 999
   >>> print b
   >>> print a
   >>> a.size
   >>> a.shape

Other Common NumPy Functions
----------------------------

numpy.arange() function
^^^^^^^^^^^^^^^^^^^^^^^

**Use:** The numpy.arange() function creates an integer array from zero to the
'stop' parameter given, with a step size of one. The 'start' and 'step'
can also be specified. By setting the parameter 'dtype' we can change
the data type of the array (i.e. to float).

Examples::

   >>> import numpy as np
   >>> np.arange(10)
   >>> 1 + np.arange(10, dtype=float) * 4
   >>> np.arange(1,40,4,dtype=float)

See also:

A similar function for lists is range().

.. admonition:: Exercise
   :class: note

   Create the sequence 0.1, 0.2,0.3, ... 1.4 using numpy.arange(). Hint: As
   noted in the NumPy documentation for numpy.arange(), it is best to use
   integer step sizes.

.. admonition:: Exercise
   :class: note

   Create the sequence -3.2, -3.0, -2.8, ... -1.0 using numpy.arange(). See
   above hint.

numpy.empty() function
^^^^^^^^^^^^^^^^^^^^^^

**Use:** The numpy.empty() function creates a float array of the specified
dimensions. Each element of the array is whatever was left in that
memory space, therefore it is fast but useful only if you know you will
assign each element a meaningful value.

Examples::

   >>> import numpy as np
   >>> np.empty(10)   #pass an argument, which is the dimensions
   >>> np.empty((3,4)) #here it is 2D, so we pass the dimensions as a tuple

See also:

Other useful similar functions are numpy.zeros(), numpy.ones().

numpy.where() function
^^^^^^^^^^^^^^^^^^^^^^

**Use:** The numpy.where() function returns an array (or a tuple of arrays) of
the indices where the condition is ``True``. Otherwise, if you
specify substitute values, it will return an array of the same shape as
the original with the first value substituted where the condition is
``True``, and the second value substituted where the condition is
``False``.

Examples::

   >>> import numpy as np
   >>> a = np.arange(11, dtype=float) + 1
   >>> b = np.where(a >= 8.)
   >>> print b
   >>> a[b]
   >>> a = np.array([1,2,3,1,2,1,1,1,1,4])
   >>> b = np.where(a == 1, 1,0)
   >>> print b

If we do not need the indices from numpy.where() then we can just use
creative indexing for the same effect. ::

   >>> a > 5
   >>> a[a>5]

See also:

Other useful similar functions are numpy.any(), numpy.all(),
numpy.nonzero(), numpy.choose().

.. admonition:: Exercise
   :class: note

   Create a random real 10-element array with numbers between 0 and 1.
   Select those with counts lower than 0.5.

.. _python_fits_ascii:

Handling FITS files and ASCII data tables using Astropy
=======================================================

Astropy is a Python library for astronomy developed by professional
astronomers and software developers from around the world, some of which
work here at STScI in the Science Software Branch. It is under
continuous development and is quickly becoming a powerful library,
especially for handling FITS files and ASCII tables. Visit the website
listed in :ref:`python_links` for more information and useful
documentation.

The astropy.io.fits module provides an interface to FITS formatted files
under the Python scripting language. astropy.io.fits data structures are
a subclass of NumPy arrays, which means that they can use NumPy arrays'
methods and attributes. The astropy.io.ascii module provides flexible
and easy-to-use methods for reading and writing ASCII data tables. In
the following sections, we will explore these two modules.

Opening, Reading, and Closing a FITS File
-----------------------------------------

As an example, we will use data from the *WFC3* instrument located here::

   /grp/hst/riab/training/python/icft01crq_raw.fits

Please copy this file to your working directory.

Below we show an example of opening a FITS file, getting the data and
the header, closing the file, printing out the shape of the data using
numpy.shape, printing out header values, and finally making changes to
the data. ::

   >>> from astropy.io import fits
   >>> infile = 'icft01crq_raw.fits'
   >>> fits.info(infile)
   >>> hdulist = fits.open(infile)
   >>> hdr = hdulist[0].header  # Get the primary header
   >>> data = hdulist[1].data  # Get the data from the 1st extension
   >>> data.shape
   >>> hdr
   >>> hdr['FLSHCORR']
   >>> hdr['FLSHCORR'] = 'PERFORM'
   >>> hdr['FLSHCORR']
   >>> print data[-2:]  # Print the last two lines.
   >>> data[-1:][0][0] = 0
   >>> print data[-1]

Notice that ``hdr`` behaves like a dictionary. We did some bad
things to this file, but let's save it anyway to a new file. ::

   >>> outfile = 'mybad.fits'
   >>> fits.writeto(outfile, data, hdr)
   >>> print 'Saved FITS file to: {}'.format(outfile)

Alternatively, if we want to modify the original file directly, we can
do the following::

   >>> fits.update(infile, data, 1)

As a word of caution, note that astropy.io.fits reads in FITS images as
(rows, cols) or (y, x), not (x, y). This is often a 'gotcha' for users
who are indexing spacific areas of the array.

fits.getval() and fits.setval() functions
-----------------------------------------

If you are familiar with IRAF/PyRAF, you are probably familiar with
IRAF's hedit function, which allows you to add, delete, and modify
keywords in a FITS header.

First, lets take a look of our example file's header using imheader in
PyRAF. In PyRAF navigate to the folder where your icft01crq\_raw.fits
file is located, and try the following::

   --> imheader icft01crq_raw.fits[0] l+ | page

We see that there is a 'DARKFILE' keyword, and it is set to
'iref$y2j13512i\_drk.fits.' Say we wanted to recalibrate this file using
a different 'DARKFILE'. The value of this keyword can be changed using
hedit, as shown here::

   --> hedit icft01crq_raw.fits[0] DARKFILE 'iref$y2p1831ci_drk.fits' \
          verify=no update=yes

In the above example we made sure the 'update' parameter was set to
'yes.' We can check that our edit was successful by using imheader again
and checking the value of the 'DARKFILE' keyword::

   --> imheader icft01crq_raw.fits[0] l+ | page

Using Python, there is a simple way to do this with astropy.io.fits
using fits.getval() and fits.setval(), shown in the example below. ::

   >>> from astropy.io import fits
   >>> infile = 'icft01crq_raw.fits'
   >>> key = 'DARKFILE'
   >>> fits.getval(infile, key, 0)
   >>> fits.setval(infile, key, value='iref$y2j13512i_drk.fits', ext=0)
   >>> fits.getval(infile, key, 0)

Now our FITS file is back to its 'initial' state. No harm done.

Reading and Writing ASCII Data Files
------------------------------------

The astropy.io.ascii module provides two robust methods, ascii.read()
and ascii.write(), for reading and writing multi-column text format data
tables.

astropy.io.ascii.read() function
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Use:** The astropy.io.ascii.read() function reads in a table of data from a
specified file and returns an astropy.Table object.

As an example, we will use these files::

   /grp/hst/riab/training/python/flux_vs_time_A.dat
   /grp/hst/riab/training/python/flux_vs_time_C.dat

These data are used to plot the flux versus time for a standard star and
serves as a monitor of the WFC3/UVIS photometric stability for amps A
and C, respectively. In this section, we will read in the data, and in
chapter 4, we will use it to produce the plots.

Examples::

   >>> from astropy.io import ascii
   >>> infile = 'flux_vs_time_A.dat'
   >>> data = ascii.read(infile,
   ...             names=['MJD', 'Flux_diff', 'Flux_err', 'Flux_linear_fit'])
   >>> print data
   >>> print data['MJD']
   >>> print data['MJD', 'Flux_diff']
   >>> print data['Flux_diff']  10
   >>> pos_flux = data['Flux_diff'] > 0
   >>> print data[pos_flux]

.. admonition:: Exercise
   :class: note

   Try reading in the data from ``flux_vs_time_C.dat`` using ascii.read()

astropy.io.ascii.write() function
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Use:** Similar to ascii.read(), the astropy.io.ascii.write() function writes
a table of data to a specified file. For fun, lets try taking the MJDs
from ``flux_vs_time_A.dat``, normalizing them to the first observation
date, and writing the new table to a new text file:

Examples::

   >>> from astropy.io import ascii
   >>> infile = 'flux_vs_time_A.dat'
   >>> data = ascii.read('flux_vs_time_A.dat',
   ...                   names=['MJD', 'Flux_diff', 'Flux_err', 'Flux_linear_fit'])
   >>> first_date = min(data['MJD'])
   >>> data['MJD'] = data['MJD'] - first_date
   >>> print data
   >>> ascii.write(data, 'flux_vs_time_A_mjdnorm.dat')

.. admonition:: Exercise
   :class: note

   Try making a MJD-normalized text file for the ``flux_vs_time_C.dat``
   data using ascii.write()

Plotting with PyPlot
====================

matplotlib.pyplot
-----------------

Matplotlib and its PyPlot environment is a versatile Python plotting
library capable of producing publication quality figures in a variety of
hard-copy formats such as EPS, PDF, and PNG. With PyPlot you can
generate scatter and line plots, histograms, power spectra, bar charts,
error-charts, pie charts, and many more with just a few lines of code.
For the power user, you have full control of line styles, font
properties, axes properties, and so on.

.. _python_simple_scatter:

Create Some Plots
-----------------

The most basic plotting function is ``plt.plot()``, which generally takes 
two arguments ``x`` and ``y``::

   x = np.arange(0,10,0.5)
   y = x**2
   plt.plot(x,y)
   plt.show()

.. figure:: figures/python/xsquared.png
   :width: 50%
   :align: center
   :alt: Our first plot.

.. tip::

   Are you doing the exercises in an IPython notebook? You can have your plots show up in the same window, in line with your code. Use ``%matplotlib inline`` before importing pyplot, like this::

      %matplotlib inline
      import matplotlib.pyplot as plt

   If you have a retina display, an additional bit of magic will make your plots much easier on the eyes::

      %config InlineBackend.figure_format='retina'

Let's look at some more things Matplotlib can do.


.. _multi_subplots:

Example: Multiple Subplots and Different Plot Functions
-------------------------------------------------------

::

   # make figure with two rows and two columns of subplots
   fig, [(ax0, ax1), (ax2, ax3)] = plt.subplots(2,2, figsize=(8,8))

   # generate two arrays of 5000 points each
   # np.random.randn pulls from normal dist centered at 0 with stddev 1
   data_x = np.random.randn(5000)
   data_y = np.random.randn(5000)

   # scatterplot
   ax0.scatter(data_x, data_y)
   ax0.set_title('plt.scatter()')

   # set number of bins for histograms
   nbins = 20

   # histogram of 1D dataset
   ax1.hist(data_x, bins=nbins)
   ax1.set_title('plt.hist()')

   # histogram of 2D dataset
   # we assign hist2d output to variables for use in the contour plot
   H, xedges, yedges, patches = ax2.hist2d(data_x, data_y, cmap='Blues', bins=(nbins,nbins))
   ax2.set_title('plt.hist2d()')

   # convert dataset to a format contourf accepts
   # don't worry if you don't understand this;
   # the point is matplotlib does contour plots
   x_bin_sizes = (xedges[1:] - xedges[:-1]).reshape((1,nbins))
   y_bin_sizes = (yedges[1:] - yedges[:-1]).reshape((nbins,1))
   pdf = (H*(x_bin_sizes*y_bin_sizes))
   X, Y = 0.5*(xedges[1:]+xedges[:-1]), 0.5*(yedges[1:]+yedges[:-1])
   Z = pdf.T

   # plot filled contour map
   cs = ax3.contourf(X, Y, Z, origin="lower", cmap='Blues')
   ax3.set_title('plt.contourf()')

   # adjust plot spacing
   fig.tight_layout()

.. figure:: figures/python/subplot_examples.png
   :width: 75%
   :align: center


Example: Plotting FITS Figures & Using Colormaps
------------------------------------------------

In Matplotlib any 2D array of floats or integers can be displayed as an image. 
This is extremely convenient for displaying data from FITS files. ::

   from astropy.io import fits

   f = fits.open('fits_images/ibsa01fpq_flt.fits')
   data = f['sci'].data
   f.close()

   # display the data
   # you may have to manually fiddle with vmin and vmax
   plt.imshow(data, vmin=3, vmax=20)

.. figure:: figures/python/fits_image.png
   :width: 50%
   :align: center

Here ``vmin`` and ``vmax`` specify the image values for which to set the minimum and maximum of the colormap.

Speaking of colormaps, let's compare some different types of colormaps for this image. ::

   # set up figure; specify size
   fig = plt.figure(figsize=(12,5))
   
   # add three subplots
   ax1 = fig.add_subplot(1,3,1)
   ax2 = fig.add_subplot(1,3,2)
   ax3 = fig.add_subplot(1,3,3)
   
   # display the image in each subplot with different colormaps
   ax1.imshow(data, vmin=3,vmax=20)
   ax2.imshow(data, vmin=3,vmax=20,cmap='RdBu_r')
   ax3.imshow(data, vmin=3,vmax=20,cmap='bone')
   
   # get rid of tick marks
   for ax in (ax1, ax2, ax3):
       ax.set_xticks([])
       ax.set_yticks([])
   
   # add titles to subplots
   ax1.set_title('Default colormap')
   ax2.set_title('Diverging colormap')
   ax3.set_title('Sequential colormap')
   fig.tight_layout()
   
   # get rid of extra spacing between subplots
   fig.subplots_adjust(hspace=0.01,wspace=0.01)

.. figure:: figures/python/colormaps.png
   :width: 100%
   :align: center

When displaying an image, there are very few instances in which you want to use anything other than a sequential colormap. Diverging colormaps are good for displaying the deviation of data from a mean or median, and qualitative colormaps such as the default "jet" should almost never be used for anything other than categorization of discrete data types. (If you don't already dislike jet, see `this blog post <https://jakevdp.github.io/blog/2014/10/16/how-bad-is-your-colormap/>`_.)

For a quick reference of all built-in colormaps in Matplotlib, see this `colormap reference chart <http://matplotlib.org/examples/color/colormaps_reference.html>`_.


Making Attractive Plots
-----------------------

As you may have noticed, the Matplotlib fonts, colors, and general 
formatting defaults are rather unattractive. Fortunately, almost 
everything in Matplotlib is customizable with a little know-how.

TeXify Your Text
^^^^^^^^^^^^^^^^

If you are preparing a document in LaTeX for publication, 
your figures will blend in very nicely (and look so much better in general!) 
if you use LaTeX formatting, not only for symbols and equations 
but for all figure text. This is the simplest method for doing so::

    # import function that allows you to adjust formatting parameters
    from matplotlib import rc
    # change default font for all plot text to LaTeX font; also change font size
    rc('font', **{'family': 'serif', 'serif': ['Computer Modern Roman'], 'size':14})
    # allow TeX commands to be used in text strings
    rc('text', usetex=True)

It is also possible to edit these preferences in your `matplotlibrc 
<http://matplotlib.org/users/customizing.html>`_ file directly; 
however, this may cause issues if you use scripts that weren't 
written with this in mind.

If you want to see everything you can possibly modify with ``rc``, 
do the following::

    from matplotlib import rcParams
    rcParams.keys()

For more information, see Matplotlib's documentation on `text 
rendering with LaTeX <http://matplotlib.org/users/usetex.html>`_.

High-DPI Rasterized Figures
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Typically, if you want to save a high-resolution figure it's easiest to just 
save it as a pdf or eps. However, the disadvantage of these formats for figures 
with large datasets is that their graphics are in vector format and thus very 
information-dense, which means that if you have upwards of a few hundred data 
points the file will quickly become bloated and you'll end up wasting twenty 
minutes while Preview struggles to open it.

Fortunately, there is a workaround. Rasterization is a process that maps vector 
graphics to pixel format, typically resulting in much less information being stored. 
In Matplotlib one can rasterize the entire figure with one simple command::

    # set up your figure
    fig = plt.figure()
    # plot some things here
    # set rasterization for the entire figure before saving
    fig.set_rasterized(True)
    # save the figure and specify the dpi
    fig.savefig('rasterized.eps', dpi=144)

A DPI of 144 should be good enough for most screens, and 300-400 for publication 
quality, although a high DPI also results in large files.

Alternatively, if you want to keep as much of the figure resolution-independent as 
possible, you can set rasterization only for the plotted objects in the plotting call::

    # set up your figure
    fig = plt.figure()
    # plot some things here and set rasterization
    plt.plot(x, y, rasterized=True)
    # save the figure and specify the dpi
    fig.savefig('partially_rasterized.eps', dpi=144)


.. _general_mpl_tricks:

General Tricks/Quick Reference
------------------------------

Legends
^^^^^^^

The function to create a legend for your plot is quite simple, although some of the details of customizing it are a bit tricky.

All you need to make a legend is at least one plotted object with the keyword argument ``label='(your label here)'``. The legend call is::

   # general
   plt.legend()
   # for a specific subplot object
   ax.legend()

This will make a boxed legend appear on top of your plot. The default legend formatting is perhaps one of Matplotlib's least attractive features, which is saying something; fortunately, it is easily customizable. For example, you can change the location, size, and handle length with the legend keyword arguments ``loc``, ``prop``, and ``handlelength`` respectively. ::

    plt.legend(loc=0, prop={'size':14}, handlelength=1)

Here ``loc=0`` tells Matplotlib to determine the optimal location for the legend. The numbering system for legend locations in Matplotlib can be confusing; the `documentation <http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend>`_, lists all numbered positions. If you need more specificity than any of these provide, you can also use ``loc=(x,y)`` where x and y specify the location of the lower left corner of the legend box in the coordinates of your axis object.

Logarithmic Axes
^^^^^^^^^^^^^^^^

If you need one or both axes to be log scale, the quickest way to do so is::

    # general
    plt.yscale('log')
    # for a specific subplot object
    ax.set_yscale('log')

Be careful when you have axis limits that are close to 0; your plots will come out very funky if you don't take care to adjust your axis limits to be log-compatible. If you have any negative data, ``plt.yscale('symlog')`` is your best option.

Alternately, you can use ``plt.semilogx(x,y)``, ``plt.semilogy(x,y)``, or ``plt.loglog(x,y)``; however, these give you slightly less flexibility.


When To Explicitly Create Figure and Axes Objects
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So far in this training we've been somewhat lax about explicit figure creation; sometimes we just do ``plt.plot(x,y)``, and sometimes we create a figure object ``fig = plt.figure()`` with or without an axes object ``ax = fig.add_subplot()``. (There's also the option ``fig, ax = plt.subplots()``). When do you need explicit figure and axes objects, and when it is okay to skip straight to the plot function?

Essentially, it depends on the complexity of your figure, although it's generally good form to use the object-oriented figure and axis calls ``fig = plt.figure()`` and ``ax = fig.add_subplot()`` when you can. For quick-and-dirty plotting, ``plt.plot()`` is generally sufficient; however, if you have multiple subplots or an otherwise complicated figure, explicitly creating figure and axis objects is easier to work with.


.. _curve_fitting:

Example: Fitting a Curve With SciPy
-----------------------------------

As astronomers, a large part of our job is to fit lines to things, 
regardless of the consequences. SciPy's `optimize 
<http://docs.scipy.org/doc/scipy-0.14.0/reference/optimize.html>`_ 
package has many useful tools for doing this;
here we will demonstrate the use of one of its most versatile functions, ``curve_fit``. ::

   # adapted from http://python4esac.github.io/fitting/example_blackbody.html

   import numpy as np
   from scipy.optimize import curve_fit
   from matplotlib import pyplot as plt
   from matplotlib import rc
   rc('font', **{'family': 'serif', 'serif': ['Computer Modern Roman'], 'size':14})
   rc('text', usetex=True)

   # define the blackbody function
   # arguments: wavelength (array-like) in microns, temp (int or float) in K
   # returns: spectral radiance over specified wavelength range
   def blackbody(wavelength, T):
       from scipy.constants import h,k,c
       wav = wavelength / 10**6
       exponential = np.exp(h*c / (wav*k*T))
       coeff = 2*h*c**2 / wav**5
       return coeff / (exponential - 1)

   # create an ideal blackbody spectrum
   # np.linspace is similar to np.arange except its third argument is an integer
   # specifying how many values the resulting array should have, instead of the 
   # size of the increment between values
   wa = np.linspace(0.02, 4, 200)
   T = 7000.
   y = blackbody(wa, T)

   # make it noisy; add both baseline and 
   # amplitude-dependent noise
   add_noise = np.random.randn(200) * np.mean(y) / 2
   multiply_noise = (np.random.randn(200) + 4) / 4

   noisy_data = y * multiply_noise + add_noise

   # fit the blackbody function to the noisy data
   # arguments: function to be fit, x and y data, initial parameter guess(es)
   # returns: optimized parameters, covariance matrix
   # curve_fit output is named popt, pcov by convention;
   # stand for optimized parameters and covariance of parameters
   popt, pcov = curve_fit(blackbody, wa, noisy_data, p0=(7000.))

   # get temperature + stdev of temperature;
   # stdev is square root of diagonal of covariance matrix
   # (we only have one free parameter here so the matrix is 1x1,
   # but it's good form to take the diagonal anyway)
   fitT = popt[0]
   sigmaT = np.sqrt(np.diag(pcov))[0]

   # fit blackbody with new temperature
   yfit = blackbody(wa, fitT)

   print 'Observed blackbody temperature: {:.2f} +/- {:.2f} K'.\
         format(fitT, sigmaT)

   # plot all functions
   fig = plt.figure()
   plt.plot(wa, y, label='True blackbody')
   plt.plot(wa, noisy_data, alpha=0.7, label='Noisy data')
   plt.plot(wa, yfit, '--', label='Fitted blackbody', lw=1)

   plt.xlabel(r'Wavelength ($\mu$m)')
   plt.ylabel('Spectral radiance (erg s$^{-1}$ cm$^3$ sr$^{-1}$)')

   plt.legend(prop={'size':14})

.. figure:: figures/python/blackbody.png
   :width: 60%
   :align: center
   :alt: Blackbody spectrum.


.. admonition:: Exercise
   :class: note

   Use ``curve_fit`` to define your own function and fit it to some noisy data.
   How do the ideal and fitted function compare?


.. _python_scripts:

Python Scripts and Functions
============================

In this chapter, we will create a Python script that performs some basic
calibration/monitoring tasks for WFC3/UVIS "hot pixels" found in DARK
images. The goal is to create a module that serves as simple yet
practical example of a script that one might write for work on an
instrument team (generally speaking of course – if this script were to
be used as part of a real calibration, it would likely be expanded and
reconfigured to be more robust). In addition, we will explore some of
Python's "best practices" that promote code readability, consistency,
reusability, etc. Our example will use standard conventions, docstrings,
and minimal redundancy. By no means should this style be used as a hard
rule or guideline, but rather a suggestion for producing high-level,
easy-to-use Python code.

Please choose a text editor for editing your script, such as
SublimeText, Emacs, TextWrangler, NEdit, or others.

.. _python_3_vs_2:

What a new Python user should know about Python 2 vs. Python 3
--------------------------------------------------------------

Python is developed by a community of volunteers and distributed for free. In 2008, this community decided to fix some long-standing bugs in the previous major version of Python (the ``2.x`` branch, which had been developed from 2000 onwards), and call the new version "Python 3". The nature of these fixes meant that users couldn't simply install Python 3 and expect everything to work immediately.

The creators of Python have decreed that Python 2 will no longer be updated, and Python 3 is the way forward. The Institute has started migrating to Python 3, but during this transitional period you should be aware that you may encounter code that works with only Python 2 (or only Python 3).

New code should be written to be forwards compatible with Python 3, *especially* if it will be used by other members of your team! There are more comprehensive guides elsewhere, but we want to call your attention to two important things that will change with Python 3. In Python 2, this code is fine::

   >>> print "Hello world"
   Hello world

In Python 3, ``print`` is a function, invoked with parentheses like every other. The above syntax won't work any more. ::

   >>> print "Hello world"
     File "<stdin>", line 1
       print "Hello world"
                         ^
   SyntaxError: Missing parentheses in call to 'print'

Add parentheses to make Python 3 happy::

   >>> print("Hello world")
   Hello world

Also, in Python 3, division will work less like computer scientists expect, and more like everyone else expects. Python 2 used "integer division", which truncated any fractional part to make the result of dividing two integers an integer. For example::

   >>> 7 / 3
   2
   >>> 7.0 / 3  # floating point division used when either operand is a float
   2.3333333333333335

In Python 3, the behavior is as follows::

   >>> 7 / 3
   2.3333333333333335
   >>> 7.0 / 3
   2.3333333333333335

The old behavior can be used with the new ``//`` operator::

   >>> 7 // 3
   2
   >>> 7.0 // 3
   2.0

What you should do about it
^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can make your code future-proof by "importing" functionality from the future. When writing stand-alone scripts (as opposed to snippets in the interactive environment), it is a good idea to include this at the top (after any ``#!`` line)::

   from __future__ import print_function, division

...and that will give you the new behavior in Python 2. (In Python 3, which already has the new behavior by default, it will have no effect.)

hotpix\_monitor.py
------------------

Our task at hand is to create a script that will construct a plot of the
number of hot pixels found in a collection of WFC3/UVIS DARK images
versus time. To determine if a pixel is "hot" or not, we will implement
a threshold that the user of the script can supply via a command-line
argument; if a pixel's value is greater than this threshold, it is
considered to be a hot pixel. The dark images are located in
``/grp/hst/riab/training/python/uvis_darks/``, and like all full-frame
UVIS images, they contain a primary header (extension 0), two SCI
extensions (extensions 1 and 4), two ERR extensions (extensions 2 and
5), and two DQ extensions (extensions 3 and 6). However, we will only
concern ourselves with extensions 0, 1, and 3 in this example.

Create a file called ``hotpix_monitor.py`` in your script directory, and
open it in your favorite editor. It is best practice to name scripts (or
modules) with all-lowercase, using underscores to separate words. The
name of your script should describe what the script does. In this case,
we chose ``hotpix_monitor.py`` because our script will monitor hot pixels!

The first thing we will put in our script is this line:

::

    #!/usr/bin/env python

This tells the computer that the Python interpreter should be used for
executing this file.

Secondly, we're writing our script to be "future-proof" for the transition to Python 3. Just after the ``#!`` line, import the new syntax from the future::

   from __future__ import print_function, division

Next, we will add a "docstring" to the beginning of the file. A docstring in Python is a string that lives at the beginning of your file (or a function, or a class) and provides guidance for people using and reading your code. They differ from comments in two ways:

- Comments are typically brief, and explain a few lines of code in context. Docstrings may be a little longer, and explain a "unit" of code (function, class, or module) at a higher level (e.g. how to use it, why you would want to).
- Docstrings are treated specially by Python. For example. when you use ``help()`` on an object, its docstring will be shown (if it has one). You can access the docstring programmatically with the ``__doc__`` attribute.

Therefore, to start off on the right foot, let's create a docstring. For our module docstring for our module. We will include:

1. A description of what the script does
2. The author(s) of the script
3. How the script is used, and
4. A description of any output products.

Our docstring should look something like this:

::

    """Monitors the hot pixel evolution of WFC3/UVIS darks.

    Authors:
        First Last, MMM YYYY

    Use:

    Outputs:

    """

We don't quite know how the script will be used yet, or what the output
products will be, so we will fill those sections in after we have
written the script. It is best practice to use three quotes (""") at the
beginning and end of your docstring, and to keep the lines in the
docstrings to maximum of 72 characters long.

Next, after the module docstring, we will import the various modules
that we will need::

    import argparse
    from astropy.io import fits
    import glob
    import numpy as np
    import matplotlib.pyplot as plt

Notice that the import statements are in alphabetical order. This is yet
another "best practice"; each import should be on its own line and in
alphabetical order.

Now we need to make our script useable from the command line. To do
this, we will add the following line after the import statements::

    if __name__ == '__main__':
        # Code goes here.

This allows any code placed under the ``if __name__ == '__main__':``
statement to be executed when the script is called from the command
line. Technically, we could put all of our code that we will type under
this code block, and it would be executed when the script is called from
the command line. However, it is better practice to make the code more
flexible by adding separate functions, each of which perform a separate
task. By having separate functions, not only could our module be
executed from the command line, but its individual functions could also
be imported by other Python modules and/or used within the Python
environment itself. This could prove to be useful if we ever want to use
the functionality that this module has to offer in other scripts. The
following shows an example of how to declare a function::

    def some_function():
        # Some code

Thus, for our script, we want our code to follow this generic workflow::

    #! /usr/bin/env python

    """
    Module docstring
    """

    def main_function():
        """
        Function docstring
        """
        # some code

    if __name__=='__main__':
        main_function()

In this way, the code contained in the main function will be executed
when the script is called from the command line *and also* can be
imported by other modules.

Before we start adding code to find hot pixels and make plots, let's add
a function that implements the threshold command line argument. We will
do this using the argparse module. Add the following code block between
your import statements and the ``if __name__ == '__main__':`` block::

    def parse_args():
        """Parse command line arguments.

        Parameters:
            nothing

        Returns:
            args : argparse.Namespace object
                An argparse object containing all of the added arguments.

        Outputs:
            nothing
        """

        parser = argparse.ArgumentParser()
        parser.add_argument('-t --threshold',
            dest='threshold',
            action='store',
            type=float,
            required=False,
            help='Pixel value to be used as hot pixel threshold (in counts)',
            default=9.0)
        args = parser.parse_args()

        return args

Notice that our function docstrings are a little different from our
module docstring. Typically, users are not concerned with how individual
functions are used, but rather what parameters/variables are needed or
returned by the function. Thus, in the function docstring, we include
descriptions of (1) what the function does, (2) the parameters that the
function requires, (3) the object(s) returned by the function, and (4)
any output(s) that the function produces upon execution.

Also notice that we split the parser.add\_argument command into several lines.
This is because it is best practice to limit non-docstring lines to 79
characters.

By grabbing what is returned from the parse\_args() function, we can now
utilize the threshold parameter. Add a call to the parse\_args()
function, as such::

    if __name__ == '__main__':
        args = parse_args()

This should leave our script looking something like this::

    #!/usr/bin/env python
    from __future__ import print_function, division
    """Monitors the hot pixel evolution of WFC3/UVIS darks.

    Authors:
        First Last, MMM YYYY

    Use:

    Outputs:

    """

    import argparse
    from astropy.io import fits
    import glob
    import numpy as np
    import matplotlib.pyplot as plt


    def parse_args():
        """Parse command line arguments.

        Parameters:
            nothing

        Returns:
            args : argparse.Namespace object
                An argparse object containing all of the added arguments.

        Outputs:
            nothing
        """

        parser = argparse.ArgumentParser()
        parser.add_argument('-t --threshold',
            dest='threshold',
            action='store',
            type=float,
            required=False,
            help='Pixel value to be used as hot pixel threshold (in counts)',
            default=9.0)
        args = parser.parse_args()

        return args


    if __name__ == '__main__':
        args = parse_args()

We know that the script must calculate the number of hot pixels in a
several images, so adding another function that will take an image and
the threshold as parameters and return the number of hot pixels and
image's observation date would be useful; we could then simply call this
function for each image in our image list and obtain the information
that we need to produce the plot. For convenience, we will calculate the
percentage of the detector occupied by hot pixels, instead of just
returning the total number of hot pixels. Thus, let's call our new
function get\_percentage\_hotpix(), and place it into our script::

    def get_percentage_hotpix(image, threshold):
        """Determine the observation date and number of hot pixels for the
        image.

        Parameters:
            image : string
                The path to the image to process.
            threshold : float
                The threshold above which pixels will be considered hot
                pixels.

        Returns:
            mjd : float
                The Modified Julian Date of the image.
            percentage_hotpix : float
                The percentage of hot pixels in SCI extension of the image.

        Outputs:
            nothing
        """

        # Open the file
        hdulist = fits.open(image)

        # Get data from the SCI and DQ extensions
        sci = hdulist[1].data
        dq = hdulist[3].data

        # Get the MJD of observation
        mjd = hdulist[0].header['EXPSTART']

        # Determine which pixels are hot pixels
        good_data = sci[np.where(dq == 0)]
        hotpix = good_data[np.where(good_data > threshold)]

        # Calculate the percentage of hot pixels
        num_pix = float(sci.size)
        num_hotpix = float(hotpix.size)
        percentage_hotpix = (num_hotpix / num_pix) * 100.

        return mjd, percentage_hotpix

Now our script should look something like this::

    #!/usr/bin/env python
    from __future__ import print_function, division
    """Monitors the hot pixel evolution of WFC3/UVIS darks.

    Authors:
        First Last, MMM YYYY

    Use:

    Outputs:

    """

    import argparse
    from astropy.io import fits
    import glob
    import numpy as np
    import matplotlib.pyplot as plt


    def get_percentage_hotpix(image, threshold):
        """Determine the observation date and number of hot pixels for the
        image.

        Parameters:
            image : string
                The path to the image to process.
            threshold : float
                The threshold above which pixels will be considered hot
                pixels.

        Returns:
            mjd : float
                The Modified Julian Date of the image.
            percentage_hotpix : float
                The percentage of hot pixels in SCI extension of the image.

        Outputs:
            nothing
        """

        # Open the file
        hdulist = fits.open(image)

        # Get data from the SCI and DQ extensions
        sci = hdulist[1].data
        dq = hdulist[3].data

        # Get the MJD of observation
        mjd = hdulist[0].header['EXPSTART']

        # Determine which pixels are hot pixels
        good_data = sci[np.where(dq == 0)]
        hotpix = good_data[np.where(good_data > threshold)]

        # Calculate the percentage of hot pixels
        num_pix = float(sci.size)
        num_hotpix = float(hotpix.size)
        percentage_hotpix = (num_hotpix / num_pix) * 100.

        return mjd, percentage_hotpix


    def parse_args():
        """Parse command line arguments.

        Parameters:
            nothing

        Returns:
            args : argparse.Namespace object
                An argparse object containing all of the added arguments.

        Outputs:
            nothing
        """

        parser = argparse.ArgumentParser()
        parser.add_argument('-t --threshold',
            dest='threshold',
            action='store',
            type=float,
            required=False,
            help='Pixel value to be used as hot pixel threshold (in counts)',
            default=9.0)
        args = parser.parse_args()

        return args


    if __name__ == '__main__':
        args = parse_args()

Notice that the get\_percentage\_hotpix() function is placed before the
parse\_args() function, even though the parse\_args() function is
executed before get\_percentage\_hotpix(). This is because it is good
practice to put functions in alphabetical order for readability
purposes. Similarly, it is best practice to leave the ``if __name__ == '__main__':``
codeblock at the end of the program.

Now we are ready to implement the core functionality; gathering hot
pixel statistics and plotting them versus time. Again, we will do this
in a separate function. Let's call it plot\_hot\_pixels(). In the
function, we will have to (1) define the list of DARK images to process,
(2) find the percentage of hot pixels for each image using the threshold
parameter, (3) plot the percentage of hot pixels versus time, and (4)
save the figure. For fun, we will also plot a vertical line representing
when a UVIS anneal occurred, in which the detector was warmed up to
reduce the number of hot pixels. Our function should look something like
this::

    def plot_hot_pixels(threshold):
        """Plots WFC3/UVIS hot pixel evolution.

        Parameters:
            threshold : float
                The threshold above which pixels will be considered hot
                pixels.

        Returns:
            nothing

        Outputs:
            hotpix.png - A plot showing the number of hot pixels over time
        """

        # Define image list
        dark_path = '/grp/hst/riab/training/python/uvis_darks/'
        dark_files = glob.glob(dark_path+'*.fits')

        # Initialize plot
        figure, ax = plt.subplots()
        ax.grid()
        ax.minorticks_on()
        ax.set_title('WFC3/UVIS Hot Pixel Evolution')
        ax.set_xlabel('Days from anneal')
        ax.set_ylabel('Number of Hot Pixels (% of Chip)')

        # Set the anneal date
        anneal = 56687.4698727

        # Plot the percentage of hot pixels
        for dark_file in dark_files:

            print 'Processing {}'.format(dark_file)

            # Determine observation time and number of hot pixels
            time, hotpix = get_percentage_hotpix(dark_file, threshold)

            # Plot the number of hot pixels vs time
            ax.scatter(time - anneal, hotpix, s=50, c='k', marker='+')

        # Plot the anneal
        ax.axvline(x=0, c='r', ls='--', lw=2, label='Anneal')

        # Place the legend
        ax.legend(loc='best')

        # Save the figure
        savefile = 'hotpix_{}.png'.format(str(threshold))
        plt.savefig(savefile)
        print 'Saved figure to {}'.format(savefile)

Great! Now we just need to call this function in our ``__main__`` code
block with our threshold parameter::

    if __name__ == '__main__':

        args = parse_args()
        plot_hot_pixels(args.threshold)

We now have all of the pieces in place, and know what our script does.
Thus, we can update our module docstrings to provide futher
explanation::

    #!/usr/bin/env python
    from __future__ import print_function, division
    """Monitors the hot pixel evolution of WFC3/UVIS darks.

    Authors:
        First Last, MMM YYYY

    Use:
        This script is inteded to be executed from the command line as
        such:

            >>> python dark_monitor.py

        The hot pixel threshold (in counts) can be specified with the -t
        or --threshold argument.  For example:

            >>> python dark_monitor.py -t 8.5

        If no threshold is specified, the default value of 9.0 counts is
        used.

    Outputs:

        hotpix_<threshold>.png -- A plot showing the number of hot pixels
                                  in each dark as a function of MJD,
                                  placed in the current working directory.

    References:

        The Python RIAB Training Document
        (https://confluence.stsci.edu/display/INSRIA/RIA+training)
    """

So, our entire script should look something like this::

    #!/usr/bin/env python
    from __future__ import print_function, division
    """Monitors the hot pixel evolution of WFC3/UVIS darks.

    Authors:
        First Last, MMM YYYY

    Use:
        This script is inteded to be executed from the command line as
        such:

            >>> python dark_monitor.py

        The hot pixel threshold (in counts) can be specified with the -t
        or --threshold argument.  For example:

            >>> python dark_monitor.py -t 8.5

        If no threshold is specified, the default value of 9.0 counts is
        used.

    Outputs:

        hotpix_<threshold>.png -- A plot showing the number of hot pixels
                                  in each dark as a function of MJD,
                                  placed in the current working directory.

    References:

        The Python RIAB Training Document
        (https://confluence.stsci.edu/display/INSRIA/RIA+training)
    """

    import argparse
    from astropy.io import fits
    import glob
    import numpy as np
    import matplotlib.pyplot as plt


    def get_percentage_hotpix(image, threshold):
        """Determine the observation date and number of hot pixels for the
        image.

        Parameters:
            image : string
                The path to the image to process.
            threshold : float
                The threshold above which pixels will be considered hot
                pixels.

        Returns:
            mjd : float
                The Modified Julian Date of the image.
            percentage_hotpix : float
                The percentage of hot pixels in SCI extension of the image.

        Outputs:
            nothing
        """

        # Open the file
        hdulist = fits.open(image)

        # Get data from the SCI and DQ extensions
        sci = hdulist[1].data
        dq = hdulist[3].data

        # Get the MJD of observation
        mjd = hdulist[0].header['EXPSTART']

        # Determine which pixels are hot pixels
        good_data = sci[np.where(dq == 0)]
        hotpix = good_data[np.where(good_data > threshold)]

        # Calculate the percentage of hot pixels
        num_pix = float(sci.size)
        num_hotpix = float(hotpix.size)
        percentage_hotpix = (num_hotpix / num_pix) * 100.

        return mjd, percentage_hotpix


    def parse_args():
        """Parse command line arguments.

        Parameters:
            nothing

        Returns:
            args : argparse.Namespace object
                An argparse object containing all of the added arguments.

        Outputs:
            nothing
        """

        parser = argparse.ArgumentParser()
        parser.add_argument('-t --threshold',
            dest='threshold',
            action='store',
            type=float,
            required=False,
            help='Pixel value to be used as hot pixel threshold (in counts)',
            default=9.0)
        args = parser.parse_args()

        return args


    def plot_hot_pixels(threshold):
        """Plots WFC3/UVIS hot pixel evolution.

        Parameters:
            threshold : float
                The threshold above which pixels will be considered hot
                pixels.

        Returns:
            nothing

        Outputs:
            hotpix.png - A plot showing the number of hot pixels over time
        """

        # Define image list
        dark_path = '/grp/hst/riab/training/python/uvis_darks/'
        dark_files = glob.glob(dark_path+'*.fits')

        # Initialize plot
        figure, ax = plt.subplots()
        ax.grid()
        ax.minorticks_on()
        ax.set_title('WFC3/UVIS Hot Pixel Evolution')
        ax.set_xlabel('Days from anneal')
        ax.set_ylabel('Number of Hot Pixels (\% of Chip)')

        # Set the anneal date
        anneal = 56687.4698727

        # Plot the percentage of hot pixels
        for dark_file in dark_files:

            print 'Processing {}'.format(dark_file)

            # Determine observation time and number of hot pixels
            time, hotpix = get_percentage_hotpix(dark_file, threshold)

            # Plot the # of hot pixels vs time
            ax.scatter(time - anneal, hotpix, s=50, c='k', marker='+')

        # Plot the anneal
        ax.axvline(x=0, c='r', ls='--', lw=2, label='Anneal')

        # Place the legend
        ax.legend(loc='best')

        # Save the figure
        savefile = 'hotpix_{}.png'.format(str(threshold))
        plt.savefig(savefile)
        print 'Saved figure to {}'.format(savefile)


    if __name__ == '__main__':

        args = parse_args()
        plot_hot_pixels(args.threshold)

Executing Python Scripts
------------------------

There are a few ways to run a Python program. One is to type from your
terminal::

   $ python hotpix_monitor.py

Or, if you are already inside the Python interactive environment, just
import the module and call its main function:

   >>> import hotpix_monitor
   >>> hotpix_monitor.plot_hot_pixels(9.0)

Lastly, since we put ``#!/usr/bin/env python`` at the top of our program, we
can execute it directly::

   $ ./hotpix_monitor.py

.. tip::

   Seeing "permission denied"? You have to mark the script file as "executable"::

      $ chmod +x ./hotpix_monitor.py

This is nice. You do not have to type 'python', you can run it from
anywhere, and you do not have to be in the Python interactive
environment.

.. admonition:: Exercise
   :class: note

   Write the script ``hotpix_monitor.py`` and execute it.

.. admonition:: Exercise
   :class: note

   Try executing ``hotpix_monitor.py`` with a different threshold. Did the
   plot change?

.. admonition:: Exercise
   :class: note

   Add another command line argument called ``-s`` or ``-–savefile``, which stores
   the plot saving location. Use this new argument to replace the
   hard-coded save location. Then, try executing the script and saving to a
   location that you pass as an argument.

Error Handling and ``pdb.set_trace()``
--------------------------------------

Debugging can be a difficult and long process, but the pdb module can
help. pdb is the Python debugger. There are many ways to use it, but a
common method is with ``pdb.set_trace()``. To debug your code using this
function, import ``pdb`` and insert the line ``pdb.set_trace()`` into your
code before the part you are unsure about. Execute the program. Once the
interpreter reaches the ``pdb.set_trace()`` mark, it will allow you to
interact with the code and print variables as they are defined. Common
``pdb.set_trace()`` commands include:

-  (n)ext: continue to the next line

-  (l)ist: list a few steps

-  (b)reak: give line and file to break at

-  (s)tep: moves into deeper calls (i.e. a function in NumPy, or our
   function mkplot).

-  (c)ontinue: continue the program like normal.

.. admonition:: Exercise
   :class: note

   Add ``import pdb`` to your list of imports in your ``hotpix_monitor.py``
   file. Insert the line ``pdb.set_trace()``. Execute your code and step
   through the program, print out variables to make sure they are what they
   are supposed to be. If they are, let the program continue.

More about Python Coding Styles and Best Practices
--------------------------------------------------

In this chapter, we have touched on some of the "best practices" that
are recommended when coding in Python. Two good resources for learning
about these best practices are PEP-8
(https://www.python.org/dev/peps/pep-0008/), which covers general
conventions, and PEP-257 (https://www.python.org/dev/peps/pep-0257/),
which discusses docstrings. If you have an interest in scripting in
Python, please take the time to review these two documents.

PyRAF
=====

PyRAF Introduction
------------------

PyRAF calls IRAF tasks from Python. One of the main motivations for
creating PyRAF is to create a version of IRAF that is compatible with a
programming language other than CL. CL has many short comings which are
more and more apparent in more complicated programs.

PyRAF has its own interactive PyRAF session. To start it, just type
``pyraf`` in a terminal. This should look familiar to you if you know
IRAF. Type ``.exit`` to exit. The remaining part of this chapter will have
you import PyRAF into Python unless otherwise stated.

A PyRAF Example with iraf.daofind()
-----------------------------------

Again, create a file in your script directory, and open it in your
favorite editor. Add your header. For your 'ABOUT' section, we will be
creating a script showing how Python can be used to execute IRAF/PyRAF
tasks. We will use some JWST/MIRI data, ``n9vf01hfq_ima.fits``, which can
be found in ``/grp/hst/riab/training/python/``.

Import the PyRAF module and from within that module import the IRAF
instance. The code for importing these functions looks like this:

::

    import pyraf
    from pyraf import iraf
    from iraf import noao, digiphot, daophot

As you can infer 'iraf' is something that lives inside of 'pyraf'. For
example, if you want to run phot on some files you need to create a list
of coordinates. To do this we will use daofind. Since daofind is an iraf
module, we execute it using dot notation, like this::

   iraf.daofind(parameter1, parameter2, parameter3)

The parameters for a PyRAF task executed in the Python environment are
the same as they would be in the PyRAF environment. Pull up a PyRAF
window and open the help file to see what the parameters for
iraf.daofind() are. Now are going to run iraf.daofind() on the file
``n9vf01hfq_ima.fits``::

    iraf.daofind(image='n9vf01hfq_ima.fits[1]')

The ``[1]`` is for extension 1. You should be prompted for several
parameters, just hit 'enter' to go through the defaults. Type ``ls`` in
the directory where you ran this – there should now be a file called
``n9vf01hfq_ima.fits1.coo.1``. In PyRAF open up the file and look at the
output, then compare this with the image on DS9. Did ``iraf.daofind()`` do a
good job? You can facilitate this process with the ``tvmark`` task::

   $ pyraf
   --> images
   --> !ds9 &
   --> display n9vf01hfq_ima.fits[1] 1

The last '1' is for which DS9 frame to display in::

   --> tv
   --> tvmark 1 n9vf01hfq_ima.fits1.coo.1

We can see that we did not to too well, but let's ignore that for now
and work on our program.

Go ahead and run this program again, and you will see that it will
create a second file called ``n9vf01hfq_ima.fits1.coo.2``. What if we did
not want so many files and instead wanted to always write to
``n9vf01hfq_ima.fits1.coo.1``? IRAF might have a problem overwriting this
file, so a simple solution would be to remove it. For this we will need
to import os. Furthermore, if we don't want to have to press :kbd:`Enter` at
the prompt, we can add to our program the extra parameters it is looking
for. Finally, let's write this program so that we can run the process on
multiple files. For that we will import ``glob``.

Here is what we have::

    #!/usr/bin/env python
    # HEADER

    #Load the packages we need
    import pyraf, os, glob
    from pyraf import iraf
    from iraf import noao, digiphot

    #Generate a list of all the fits files
    file_list = glob.glob('*_ima.fits')
    print file_list

    #Loops through all the .fits files
    for ima in file_list:
        #Test for old files, and remove them if they exist
        file_query = os.access(ima + '1.coo.1', os.R_OK)
        if file_query == True:
            os.remove(ima + '1.coo.1')
        #Run daofind on one image
        iraf.daofind(
            image = ima + '[1]',
            interactive = 'no',
            verify = 'no')

.. admonition:: Exercise
   :class: note

   Write your script that uses iraf.daofind(). Anytime you change the default settings to a PyRAF command it is a good
   idea to change them back. You can do this with the iraf.unlearn()
   command as shown below. ::

      --> iraf.daofind.unlearn()
      --> iraf.unlearn('daofind')



Resources
=========

.. _python_links:

Useful Links
-------------

Below is a list of links to be used as a reference.

-  http://docs.python.org/

-  http://legacy.python.org/dev/peps/pep-0008/

-  http://www.astropy.org/

-  http://wiki.python.org/moin/HowTo/Sorting

-  http://ipython.scipy.org/moin/Documentation

-  http://matplotlib.sourceforge.net/

-  http://www.scipy.org/Numpy_Example_List_With_Doc

-  http://docs.scipy.org/doc/

-  http://www.scipy.org/Cookbook

The following links are for further training and building of your Python
skills.

-  http://stsdas.stsci.edu/perry/pydatatut.pdf

-  http://www.scipy.org/Additional_Documentation/Astronomy_Tutorial?action=show

-  http://python4astronomers.github.com/

-  http://code.google.com/edu/languages/google-python-class/

-  http://learnpythonthehardway.org/book/

-  http://www.pythonchallenge.com/

-  http://www.astro.washington.edu/users/vanderplas/Astr599_2014/notebooks/

And, a few libraries to help make your plots pretty:

-  https://github.com/yhat/ggplot

-  https://plot.ly/

-  https://github.com/olgabot/prettyplotlib

-  http://stanford.edu/~mwaskom/software/seaborn/index.html


Mailing Lists
-------------

These Python themed STScI e-mail lists are available through the Outlook
Web App (OWA):

-  **pylunch**: A mailing list for a lunch group that presents and discusses
   Python related material.

-  **python-interested**: A mailing list usually used to discuss bugs,
   fixes, and how to do some outrageous tasks that astronomers come up
   with.

.. rubric:: Footnotes

.. [#pythontutorial] An extensive Python tutorial is available from the Python developers themselves: https://docs.python.org/2/tutorial/introduction.html. (For Python 3, the updated tutorial is at https://docs.python.org/3/tutorial/introduction.html.)
.. [#iterationtuple] Under the hood, ``enumerate()`` is really making an ``(index, element)`` *tuple* for every element in ``mytuple``! By putting ``idx, item`` in the ``for`` statement, you're "unpacking" the tuple into two separate variables, just like we did in the variable assignment example with multiple left-hand-side values.
.. [#hashable] What's "hashable"? In practice, you won't care about this beyond the fact that lists don't make for good dictionary keys. Python internally calculates a place to store your value based on the key, and to do that consistently requires that the key be *immutable*. See the `Python glossary <https://docs.python.org/glossary.html#term-hashable>`_ for gory details.
