{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "Introduction\n",
    "============\n",
    "\n",
    "This notebook will guide you through the mechanical basics of doing photometry. For these exercises we will use *photutils*, but there are many different other tools one can use to extract photometry from images (DAOPHOT, DOLPHOT, SEXTRACTOR, EPSF).\n",
    "This tutorial is based on the [photutils](http://http://photutils.readthedocs.io) documentation. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "%pylab --no-import-all\n",
    "from photutils import datasets\n",
    "from astropy.visualization import LogStretch\n",
    "from astropy.visualization.mpl_normalize import ImageNormalize\n",
    "import matplotlib.pylab as plt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Image Display\n",
    "-------------\n",
    "We will now download and display an example image."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "hdu = datasets.load_star_image()    \n",
    "\n",
    "data = hdu.data[0:400, 0:400]    \n",
    "\n",
    "norm = ImageNormalize(stretch=LogStretch())\n",
    "plt.imshow(data, cmap='Greys', origin='lower', norm=norm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Source Detection\n",
    "----------------\n",
    "Before we do photometry we want to find all the sources in the image. We first measure some statistics about the image. We are interested in the background statistics so we subtract it and also determine which stars are 5$\\sigma$ detections. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "from astropy.stats import sigma_clipped_stats\n",
    "from photutils import daofind\n",
    "\n",
    "mean, median, std = sigma_clipped_stats(data, sigma=3.0, iters=5)    \n",
    "print(mean, median, std)  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "sources = daofind(data - median, fwhm=3.0, threshold=5.*std)    \n",
    "print(sources) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "from photutils import CircularAperture\n",
    "\n",
    "positions = (sources['xcentroid'], sources['ycentroid'])\n",
    "apertures = CircularAperture(positions, r=5.)\n",
    "apertures.plot(color='blue', lw=1.5, alpha=0.5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "Aperture photometry\n",
    "-------------------\n",
    "Now that we have the positions of stars, we can proceed with measuring their fluxes. When we first measure the fluxes of stars, they include the sky background. We will subtract that later."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "from photutils import CircularAnnulus\n",
    "from photutils import aperture_photometry\n",
    "\n",
    "apertures_r3 = CircularAperture((sources['xcentroid'], sources['ycentroid']), r=3.)\n",
    "\n",
    "phot_table = aperture_photometry(data, apertures_r3)\n",
    "print(phot_table)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the following cells we create annuli apertures to measure the average value of the pixels around each star. We multiply the average sky value by the number of pixels under the aperture and then subtract that value from the total star flux."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "annulus_apertures = CircularAnnulus(positions, r_in=9., r_out=12.)\n",
    "rawflux_r3 = aperture_photometry(data, apertures_r3)\n",
    "bkgflux_table = aperture_photometry(data, annulus_apertures)\n",
    "\n",
    "bkg_mean = bkgflux_table['aperture_sum'] / annulus_apertures.area()\n",
    "print(bkg_mean)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "bkg_sum = bkg_mean * apertures_r3.area()\n",
    "print(bkg_sum)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "final_phot_r3 = rawflux_r3['aperture_sum'] - bkg_sum\n",
    "print(final_phot_r3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Aperture corrections\n",
    "--------------------\n",
    "The above photometry was performed with a small aperture to increase the signal to noise of our measurement. The problem with that is that we are missing some light from each star. To compensate we will do photometry with a large radius. The difference in magnitude from the two aperture measurements is the aperture correction. This correction is applied to all the stars at the end."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "apertures_r5 = CircularAperture((sources['xcentroid'], sources['ycentroid']), r=5.) #note the larger aperture\n",
    "rawflux_r5 = aperture_photometry(data, apertures_r5)\n",
    "\n",
    "bkg_sum = bkg_mean * apertures_r5.area()\n",
    "final_phot_r5 = rawflux_r5['aperture_sum'] - bkg_sum"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now you need to convert these fluxes into magnitudes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "mag_r3 = -2.5*np.log10(final_phot_r3)\n",
    "mag_r5 = -2.5*np.log10(final_phot_r5)\n",
    "deltamag = mag_r3 - mag_r5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "plt.clf()\n",
    "plt.scatter(mag_r5,deltamag)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "plt.clf()\n",
    "plt.scatter(mag_r5,mag_r3-mag_r5,c='k',edgecolors='none')\n",
    "plt.axhline(ls='--',c='b')\n",
    "plt.xlim(-15,-8)\n",
    "plt.ylim(-1,1)\n",
    "plt.xlabel('Mag [r=5]',fontsize=18)\n",
    "plt.ylabel('$\\Delta$mag',fontsize=18)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "mask = [(mag_r5>-13.)&(mag_r5<-11.)&(deltamag>0.)&(deltamag<0.4)]\n",
    "\n",
    "mean, median, std = sigma_clipped_stats(deltamag[mask], sigma=3.0, iters=5)\n",
    "apcor = median\n",
    "print(apcor)\n",
    "\n",
    "plt.axhline(apcor,ls='-',c='r')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "final_phot =-2.5*np.log10(final_phot_r3) + apcor + 25."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "print(final_phot)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Exercise\n",
    "--------\n",
    "\n",
    "Use the images you made in the Astrodrizzle exercise to make a color magnitude diagram (F606W-F814W vs F814W). \n",
    "\n",
    "1. You will first have to change the drizzled images back to counts. \n",
    "2. Find sources on one image, use the same catalog for both images.\n",
    "3. Do photometry on each image, including aperture correction plots.\n",
    "4. Match catalogs, and plot CMD.\n",
    "\n",
    "Send me three plots: the aperture correction for each band and the CMD. Each plot should be clearly labeled. \n",
    "\n",
    "Below is some information you might need:\n",
    "\n",
    "\\begin{equation}\n",
    "rescale = 0.03/0.049 \\\\\n",
    "counts\\_image = cps\\_image \\times exptime + \\frac{\\Sigma{mdrizsky}}{2}sky \\times rescale^2\n",
    "\\end{equation}\n",
    "\n",
    "The information you need can be found in the image header and in the fits table found in the last extension of the image."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "from astropy.io import fits\n",
    "\n",
    "fits.info('F606W_drc.fits')\n",
    "hdu = fits.open('F606W_drc.fits')\n",
    "sci = hdu[1].data\n",
    "hdr = hdu[0].header\n",
    "tab = hdu[4].data\n",
    "hdu.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "tab['mdrizsky']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "(0.03/0.05)**2*np.sum(tab['mdrizsky'])/2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "a = sci*hdr['texptime']+(0.03/0.05)**2*np.sum(tab['mdrizsky'])/2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "fits.writeto('F606W_cts.fits',a,header=hdr)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Tips\n",
    "----\n",
    "\n",
    "- Remember, on a CMD, the y-axis goes from bright stars at top to faint stars on the bottom."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
