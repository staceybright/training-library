\chapter{Python Scripts and Functions}
\label{ch:scripts}

In this chapter, we will create a python script that performs some
basic calibration/monitoring tasks for WFC3/UVIS ``hot pixels'' found in
DARK images.  The goal is to create a module that serves as simple yet
practical example of a script that one might write for work on an instrument
team (generally speaking of course -- if this script were to be used as part
of a real calibration, it would likely be expanded and reconfigured to be
more robust).  In addition, we will explore some of python's ``best practices'' that
promote code readability, consistency, reusability, etc.  Our example will use standard 
conventions, docstrings, and minimal redundancy.  By no means should this style be used as
a hard rule or guideline, but rather a suggestion for producing high-level,
easy-to-use python code.

Make a directory where you will keep all your script.  You will also need to 
choose a text editor, such as SublimeText, Emacs, TextWrangler, NEdit,
or others.  You will be using this to edit your script.
 
\section{hotpix\_monitor.py}

Our task at hand is to create a script that will construct a plot of the number 
of hot pixels found in a collection of WFC3/UVIS DARK images versus time. To determine if a pixel 
is ``hot'' or not, we will implement a threshold that the user of the script can 
supply via a command-line argument; if a pixel's value is greater than this threshold, 
it is considered to be a hot pixel.  The dark images are located in 
/user/gunning/Python\_Training/uvis\_darks/, and like all full-frame UVIS images, they contain 
a primary header (extension 0), two SCI extensions (extensions 1 and 4), two ERR extensions
(extensions 2 and 5), and two DQ extensions (extensions 3 and 6).  However, we will only 
concern ourselves with extensions 0, 1, and 3 in this example.

Create a file called {\sf\small hotpix\_monitor.py} in your script directory, and
open it in your favorite editor.  It is best practice to name scripts (or modules) 
with all-lowercase, using underscores to separate words.  The name of your script
should describe what the script does.  In this case, we chose {\sf\small hotpix\_monitor.py}
because our script will monitor hot pixels!

The first thing we will put in our script is this line:

\begin{verbatim}
#! /usr/bin/env python
\end{verbatim}

This tells the computer that the python interpreter should be used for executing this file.

Comments, or ``docstrings'' in scripts are very important, not just to help you 
remember what exactly you were thinking, but to help others as well should 
they ever use your code. Therefore, to start off on the right foot, let's create 
a docstring.  For our module docstring for our module.  We will include (1) A description
of what the script does, (2) The author(s) of the script, (3) how the script is used,
and (4) a descrption of any output products.  Our docstring should look something like
this:

\begin{verbatim}
"""Monitors the hot pixel evolution of WFC3/UVIS darks.

Authors:
    First Last, MMM YYYY

Use:

Outputs:

"""
\end{verbatim}

We don't quite know how the script will be used yet, or what the output products
will be, so we will fill those sections in after we have written the script.  It is
best practice to use three quotes (""") at the beginning and end of your docstring, and
to keep the lines in the docstrings to maximum of 72 characters long.

Next, after the module docstring, we will import the various modules that we will need:

\begin{verbatim}
import argparse
from astropy.io import fits
import glob
import numpy as np
import matplotlib.pyplot as plt
\end{verbatim}

Notice that the import statements are in alphebetical order.  This is yet another 
``best practice''; each import should be on its own line and in alphabetical order.

Now we need to make our script useable from the command line.  To do this, we will add
the following line after the import statements:

\begin{verbatim}
if __name__ == '__main__':
    # Code goes here.
\end{verbatim}

This allows any code placed under the {\sf\small if \_\_name\_\_ == `\_\_main\_\_'} statement 
to be executed when the script is called from the command line.  Technically, we could 
put all of our code that we will type under this code block, 
and it would be executed when the script is called from the command line.  
However, it is better practice to make the code more flexible by adding separate 
functions, each of which perform a separate task.  By having separate functions, not only 
could our module be executed from the command line, but its individual functions could also be 
imported by other python modules and/or used within the python environment itself. 
This could prove to be useful if we ever want to use the functionality that this module has to 
offer in other scripts.  The following shows an example of how to declare a function:

\begin{verbatim}
def some_function()
    # Some code
\end{verbatim}

Thus, for our script, we want our code to follow this generic workflow:

\begin{verbatim}
#! /usr/bin/env python

"""
Module docstring
"""

def main_function()
    """
    Function docstring
    """
    # some code

if __name__=='__main__':
    main_function()
\end{verbatim}

In this way, the code contained in the main function will be executed when the script is
called from the command line \textit{and also} can be imported by other modules.

Before we start adding code to find hot pixels and make plots, let's add a function
that implements the threshold command line argument.  We will do this using the {\sf\small argparse}
module.  Add the following code block between your import statements and the {\sf\small if \_\_name\_\_ == `\_\_main\_\_'}
block:

\begin{verbatim}
def parse_args():
    """Parse command line arguments.

    Parameters:
        nothing

    Returns:
        args : argparse.Namespace object
            An argparse object containing all of the added arguments.

    Outputs:
        nothing
    """

    parser = argparse.ArgumentParser()
    parser.add_argument('-t --threshold',
        dest='threshold',
        action='store',
        type=float,
        required=False,
        help='Pixel value to be used as hot pixel threshold (in counts)',
        default=9.0)
    args = parser.parse_args()

    return args
\end{verbatim}

Notice that our function docstrings are a little different from our module docstring.  Typically,
users are not concerned with how individual functions are used, but rather what parameters/variables
are needed or returned by the function.  Thus, in the function docstring, we include descriptions of 
(1) what the function does, (2) the parameters that the function requires, (3) the object(s) returned 
by the function, and (4) any output(s) that the function produces upon execution.  Also notice that we 
split the {\sf\small parser.add\_argument} command into several lines.  This is
because it is best practice to limit non-docstring lines to 80 characters.

By grabbing what is returned from the {\sf\small parse\_args()} function, we can now
utilize the threshold parameter.  Add a call to the {\sf\small parse\_args()} function,
as such:

\begin{verbatim}
if __name__=='__main__':
    args = parse_args()
\end{verbatim}

This should leave our script looking something like this:

\begin{verbatim}
#! /usr/bin/env python

"""Monitors the hot pixel evolution of WFC3/UVIS darks.

Authors:
    First Last, MMM YYYY

Use:

Outputs:

"""

import argparse
from astropy.io import fits
import glob
import numpy as np
import matplotlib.pyplot as plt


def parse_args():
    """Parse command line arguments.

    Parameters:
        nothing

    Returns:
        args : argparse.Namespace object
            An argparse object containing all of the added arguments.

    Outputs:
        nothing
    """

    parser = argparse.ArgumentParser()
    parser.add_argument('-t --threshold',
        dest='threshold',
        action='store',
        type=float,
        required=False,
        help='Pixel value to be used as hot pixel threshold (in counts)',
        default=9.0)
    args = parser.parse_args()

    return args


if __name__=='__main__':
    args = parse_args()

\end{verbatim}

We know that the script must calculate the number of hot pixels in a
several images, so adding another function that will take an image and
the threshold as parameters and return the number of hot pixels and image's 
observation date would be useful; we could then simply call this function for
each image in our image list and obtain the information that we need to produce
the plot.  For convenience, we will calculate the percentage of the detector 
occupied by hot pixels, instead of just returning the total number of hot pixels.  
Thus, let's call our new function {\sf\small get\_percentage\_hotpix()}, 
and place it into our script:

\begin{verbatim}
def get_percentage_hotpix(image, threshold):
    """Determine the observation date and number of hot pixels for the
    image.

    Parameters:
        image : string
            The path to the image to process.
        threshold : float
            The threshold above which pixels will be considered hot
            pixels.

    Returns:
        mjd : float
            The Modified Julian Date of the image.
        percentage_hotpix : float
            The percentage of hot pixels in SCI extension of the image.

    Outputs:
        nothing
    """

    # Open the file
    hdulist = fits.open(image)

    # Get data from the SCI and DQ extensions
    sci = hdulist[1].data
    dq = hdulist[3].data

    # Get the MJD of observation
    mjd = hdulist[0].header['EXPSTART']

    # Determine which pixels are hot pixels
    good_data = sci[np.where(dq == 0)]
    hotpix = good_data[np.where(good_data > threshold)]

    # Calculate the percentage of hot pixels
    num_pix = float(sci.size)
    num_hotpix = float(hotpix.size)
    percentage_hotpix = (num_hotpix / num_pix) * 100.

    return mjd, percentage_hotpix
\end{verbatim}

Now our script should look something like this:

\begin{verbatim}
#! /usr/bin/env python

"""Monitors the hot pixel evolution of WFC3/UVIS darks.

Authors:
    First Last, MMM YYYY

Use:

Outputs:

"""

import argparse
from astropy.io import fits
import glob
import numpy as np
import matplotlib.pyplot as plt


def get_percentage_hotpix(image, threshold):
    """Determine the observation date and number of hot pixels for the
    image.

    Parameters:
        image : string
            The path to the image to process.
        threshold : float
            The threshold above which pixels will be considered hot
            pixels.

    Returns:
        mjd : float
            The Modified Julian Date of the image.
        percentage_hotpix : float
            The percentage of hot pixels in SCI extension of the image.

    Outputs:
        nothing
    """

    # Open the file
    hdulist = fits.open(image)

    # Get data from the SCI and DQ extensions
    sci = hdulist[1].data
    dq = hdulist[3].data

    # Get the MJD of observation
    mjd = hdulist[0].header['EXPSTART']

    # Determine which pixels are hot pixels
    good_data = sci[np.where(dq == 0)]
    hotpix = good_data[np.where(good_data > threshold)]

    # Calculate the percentage of hot pixels
    num_pix = float(sci.size)
    num_hotpix = float(hotpix.size)
    percentage_hotpix = (num_hotpix / num_pix) * 100.

    return mjd, percentage_hotpix


def parse_args():
    """Parse command line arguments.

    Parameters:
        nothing

    Returns:
        args : argparse.Namespace object
            An argparse object containing all of the added arguments.

    Outputs:
        nothing
    """

    parser = argparse.ArgumentParser()
    parser.add_argument('-t --threshold',
        dest='threshold',
        action='store',
        type=float,
        required=False,
        help='Pixel value to be used as hot pixel threshold (in counts)',
        default=9.0)
    args = parser.parse_args()

    return args


if __name__=='__main__':
    args = parse_args()

\end{verbatim}

Notice that the {\sf\small get\_percentage\_hotpix()} function is placed before the {\sf\small parse\_args()}
function, even though the {\sf\small parse\_args()} function is executed before {\sf\small get\_percentage\_hotpix()}.
This is because it is good practice to put functions in alphabetical order for readability
pruposes.  Similarly, it is best practice to leave the {\sf\small if \_\_name\_\_=='\_\_main\_\_'} codeblock
at the end of the program.

Now we are ready to implement the core functionality; gathering hot pixel statistics and
plotting them versus time.  Again, we will do this in a separate function.  Let's call it {\sf\small plot\_hot\_pixels()}.
In the function, we will have to (1) define the list of DARK images to process, (2) find the percentage
of hot pixels for each image using the threshold parameter, (3) plot the percentage of hot 
pixels versus time, and (4) save the figure.  For fun, we will also plot a vertical line 
representing when a UVIS anneal occured, in which the detector was warmed up to reduce the 
number of hot pixels.  Our function should look something like this:

\begin{verbatim}
def plot_hot_pixels(threshold):
    """Plots WFC3/UVIS hot pixel evolution.

    Parameters:
        threshold : float
            The threshold above which pixels will be considered hot
            pixels.

    Returns:
        nothing

    Outputs:
        hotpix.png - A plot showing the number of hot pixels over time
    """

    # Define image list
    dark_files = glob.glob('/user/gunning/Python_Training/uvis_darks/*.fits')

    # Initialize plot
    figure, ax = plt.subplots()
    ax.grid()
    ax.minorticks_on()
    ax.set_title('WFC3/UVIS Hot Pixel Evolution')
    ax.set_xlabel('Days from anneal')
    ax.set_ylabel('Number of Hot Pixels (% of Chip)')

    # Set the anneal date
    anneal = 56687.4698727

    # Plot the percentage of hot pixels
    for dark_file in dark_files:

        print 'Processing {}'.format(dark_file)

        # Determine observation time and number of hot pixels
        time, hotpix = get_percentage_hotpix(dark_file, threshold)

        # Plot the number of hot pixels vs time
        ax.scatter(time - anneal, hotpix, s=50, c='k', marker='+')

    # Plot the anneal
    ax.axvline(x=0, c='r', ls='--', lw=2, label='Anneal')

    # Place the legend
    ax.legend(loc='best')

    # Save the figure
    savefile = 'hotpix_{}.png'.format(str(threshold))
    plt.savefig(savefile)
    print 'Saved figure to {}'.format(savefile)
\end{verbatim}

Great! Now we just need to call this function in our {\sf\small \_\_main\_\_} code block with
our threshold parameter:

\begin{verbatim}
if __name__ == '__main__':

    args = parse_args()
    plot_hot_pixels(args.threshold)

\end{verbatim}

We now have all of the pieces in place, and know what our script does.  Thus, we can
update our module docstrings to provide futher explainiation:

\begin{verbatim}
#! /usr/bin/env python

"""Monitors the hot pixel evolution of WFC3/UVIS darks.

Authors:
    First Last, MMM YYYY

Use:
    This script is inteded to be executed from the command line as
    such:

        >>> python dark_monitor.py

    The hot pixel threshold (in counts) can be specified with the -t 
    or --threshold argument.  For example:

        >>> python dark_monitor.py -t 8.5

    If no threshold is specified, the default value of 9.0 counts is 
    used.

Outputs:

    hotpix_<threshold>.png -- A plot showing the number of hot pixels 
                              in each dark as a function of MJD, 
                              placed in the current working directory.

References:

    The Python RIAB Traning Document
    (https://confluence.stsci.edu/display/INSRIA/RIA+training)
"""
\end{verbatim}

So, our entire script should look something like this:

\begin{verbatim}
#! /usr/bin/env python

"""Monitors the hot pixel evolution of WFC3/UVIS darks.

Authors:
    First Last, MMM YYYY

Use:
    This script is inteded to be executed from the command line as
    such:

        >>> python dark_monitor.py

    The hot pixel threshold (in counts) can be specified with the -t 
    or --threshold argument.  For example:

        >>> python dark_monitor.py -t 8.5

    If no threshold is specified, the default value of 9.0 counts is 
    used.

Outputs:

    hotpix_<threshold>.png -- A plot showing the number of hot pixels 
                              in each dark as a function of MJD, 
                              placed in the current working directory.

References:

    The Python RIAB Traning Document
    (https://confluence.stsci.edu/display/INSRIA/RIA+training)
"""

import argparse
from astropy.io import fits
import glob
import numpy as np
import matplotlib.pyplot as plt


def get_percentage_hotpix(image, threshold):
    """Determine the observation date and number of hot pixels for the
    image.

    Parameters:
        image : string
            The path to the image to process.
        threshold : float
            The threshold above which pixels will be considered hot
            pixels.

    Returns:
        mjd : float
            The Modified Julian Date of the image.
        percentage_hotpix : float
            The percentage of hot pixels in SCI extension of the image.

    Outputs:
        nothing
    """

    # Open the file
    hdulist = fits.open(image)

    # Get data from the SCI and DQ extensions
    sci = hdulist[1].data
    dq = hdulist[3].data

    # Get the MJD of observation
    mjd = hdulist[0].header['EXPSTART']

    # Determine which pixels are hot pixels
    good_data = sci[np.where(dq == 0)]
    hotpix = good_data[np.where(good_data > threshold)]

    # Calculate the percentage of hot pixels
    num_pix = float(sci.size)
    num_hotpix = float(hotpix.size)
    percentage_hotpix = (num_hotpix / num_pix) * 100.

    return mjd, percentage_hotpix


def parse_args():
    """Parse command line arguments.

    Parameters:
        nothing

    Returns:
        args : argparse.Namespace object
            An argparse object containing all of the added arguments.

    Outputs:
        nothing
    """

    parser = argparse.ArgumentParser()
    parser.add_argument('-t --threshold',
        dest='threshold',
        action='store',
        type=float,
        required=False,
        help='Pixel value to be used as hot pixel threshold (in counts)',
        default=9.0)
    args = parser.parse_args()

    return args


def plot_hot_pixels(threshold):
    """Plots WFC3/UVIS hot pixel evolution.

    Parameters:
        threshold : float
            The threshold above which pixels will be considered hot
            pixels.

    Returns:
        nothing

    Outputs:
        hotpix.png - A plot showing the number of hot pixels over time
    """

    # Define image list
    dark_files = glob.glob('/user/gunning/Python_Training/uvis_darks/*.fits')

    # Initialize plot
    figure, ax = plt.subplots()
    ax.grid()
    ax.minorticks_on()
    ax.set_title('WFC3/UVIS Hot Pixel Evolution')
    ax.set_xlabel('Days from anneal')
    ax.set_ylabel('Number of Hot Pixels (% of Chip)')

    # Set the anneal date
    anneal = 56687.4698727

    # Plot the percentage of hot pixels
    for dark_file in dark_files:

        print 'Processing {}'.format(dark_file)

        # Determine observation time and number of hot pixels
        time, hotpix = get_percentage_hotpix(dark_file, threshold)

        # Plot the # of hot pixels vs time
        ax.scatter(time - anneal, hotpix, s=50, c='k', marker='+')

    # Plot the anneal
    ax.axvline(x=0, c='r', ls='--', lw=2, label='Anneal')

    # Place the legend
    ax.legend(loc='best')

    # Save the figure
    savefile = 'hotpix_{}.png'.format(str(threshold))
    plt.savefig(savefile)
    print 'Saved figure to {}'.format(savefile)


if __name__ == '__main__':

    args = parse_args()
    plot_hot_pixels(args.threshold)

\end{verbatim}

\section{Executing Python Scripts}

There are a few ways to run a Python program.  One is to type from your terminal:

\texttt{\termtab python hotpix\_monitor.py}

Or, if you are already inside the Python interactive environment, just
import the module and call its main function:

\texttt{\pytab import hotpix\_monitor} \\
\texttt{\pytab hotpix\_monitor.plot\_hot\_pixels(9.0)}

Lastly, since we put {\sf\small \#\! /usr/bin/env python} at the top of our program, we can
execute it directly:

\texttt{\termtab hotpix\_monitor.py}

This is nice.  You do not have to type `python', you can run it from
anywhere, and you do not have to be in the Python interactive
environment.  To be able to call your script from anywhere on your computer, add
your script directory to your executable PATH:

\texttt{setenv PATH .:/my/script/directory:\{\$PATH\}}

{\color{blue} {\sf\small EXERCISES}} \\
{\it Exercise \arabic{exercise} \stepcounter{exercise}:  \\
  Write the script {\sf\small hotpix\_monitor.py} and execute it.
} \\
{\it Exercise \arabic{exercise} \stepcounter{exercise}:  \\
  Try executing {\sf\small hotpix\_monitor.py} with a different threshold.  Did the plot
  change?
}

\section{Error Handling and {\sf pdb.set\_trace()}}
Debugging can be a difficult and long process, but the {\sf\small pdb}
module can help.  {\sf\small pdb} is the Python debugger.  There are
many ways to use it, but a common method is with {\sf\small
  pdb.set\_trace()}.  To debug your code using this function, import
{\sf\small pdb} and insert the line \texttt{pdb.set\_trace()} into your
code before the part you are unsure about.  Execute the program.  Once
the interpreter reaches the \texttt{pdb.set\_trace()} mark, it will
allow you to interact with the code and print variables as they are
defined.   Common {\sf\small pdb.set\_trace()} commands include:
\begin{itemize}
\item (n)ext:    continue to the next line
\item (l)ist:      list a few steps
\item (b)reak:  give line and file to break at
\item (s)tep:    moves into deeper calls (i.e. a function in NumPy, or
  our function {\sf\small mkplot}).
\item (c)ontinue: continue the program like normal.
\end{itemize}

{\color{blue} {\sf\small EXERCISES}} \\
{\it Exercise \arabic{exercise} \stepcounter{exercise}:  \\
  Add \texttt{import pdb} to your list of imports in your
  {\sf\small hotpix\_monitor.py file}.  Insert the line \texttt{pdb.set\_trace()}.
  Execute your code and step through the program, print out variables
  to make sure they are what they are supposed to be.  If they are, 
  let the program continue. }

\section{More about Python Coding Styles and Best Practices}
In this chapter, we have touched on some of the ``best practices'' that are
recommended when coding in Python.  Two good resources for learning about
these best practices are PEP-8 (\url {http://legacy.python.org/dev/peps/pep-0008/}),
which covers general conventions, and PEP-257 (\url {http://legacy.python.org/dev/peps/pep-0257/}),
which discusses docstrings.  Below is a summary of some of the conventions discussed in these 
documents, but please consider reading PEP-8 and PEP-257 for further details.


